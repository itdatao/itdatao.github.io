<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"itdatao.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"border_radius":8,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="很久之前想读但是没读完的书，Effective Java读书笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="effective Java">
<meta property="og:url" content="http://itdatao.github.io/posts/21283aa4/index.html">
<meta property="og:site_name" content="洛传的个人空间">
<meta property="og:description" content="很久之前想读但是没读完的书，Effective Java读书笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-26T07:38:05.000Z">
<meta property="article:modified_time" content="2024-10-13T09:10:48.589Z">
<meta property="article:author" content="H2T">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://itdatao.github.io/posts/21283aa4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css">
  <title>effective Java | 洛传的个人空间</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">洛传的个人空间</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">this is an interesting blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://itdatao.github.io/posts/21283aa4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s2.loli.net/2023/02/26/PVfcsSojHARqp1y.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="洛传的个人空间">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          effective Java
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-26 15:38:05" itemprop="dateCreated datePublished" datetime="2023-02-26T15:38:05+08:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-13 17:10:48" itemprop="dateModified" datetime="2024-10-13T17:10:48+08:00">2024-10-13</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>很久之前想读但是没读完的书，Effective Java读书笔记。</p>
<span id="more"></span>

<h1 id="第一章-创建和销毁对象"><a href="#第一章-创建和销毁对象" class="headerlink" title="第一章 创建和销毁对象"></a>第一章 创建和销毁对象</h1><h2 id="1-考虑用静态代替构造方法"><a href="#1-考虑用静态代替构造方法" class="headerlink" title="1. 考虑用静态代替构造方法"></a>1. 考虑用静态代替构造方法</h2><p>想要获取一个类的实例，一种传统的方式是通过共有的构造器，当然还可以使用另一种技术：提供共有的静态工厂方法。</p>
<!--more-->

<p>什么是静态工厂？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要用静态工厂替换构造方法？有什么优点</p>
<ol>
<li>静态工厂相比构造器来讲，有名字并且通俗易懂，构造器的名字必须和类名一致</li>
<li>静态工厂每次调用不必新建对象。所以适用于不可变的类，单例，初始化就缓存好，避免重复创建。</li>
<li>静态工厂方法能够返回原先返回类型的任意子类型的对象，更加灵活的选择返回对象。例如Collection有32个实现类在Collections中可以返回。</li>
<li>静态工厂可以根据调用传入的不同参数返回不同的对象。</li>
</ol>
<p>静态工厂的不足之处？</p>
<ol>
<li>静态工厂没有public和protected的方法，因此不能被子类化。</li>
</ol>
<p>一般静态工厂方法名字的含义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fromValue(value) <span class="comment">//这种通过传入单个参数返回相应类型的实例对象</span></span><br><span class="line">of(v1,v2,v3) <span class="comment">// 传入多个参数，返回报站这些参数的实例。</span></span><br><span class="line"><span class="comment">// valueOf是from of更详细的替代方案</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">prime</span> <span class="operator">=</span> BigInteger.valueOf(Integer.MAX_VALUE);</span><br><span class="line"><span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(classObject, arrayLen);<span class="comment">//每次返回的对象都是新的实例</span></span><br></pre></td></tr></table></figure>

<h2 id="2-当遇到多个构造器使用构建者"><a href="#2-当遇到多个构造器使用构建者" class="headerlink" title="2. 当遇到多个构造器使用构建者"></a>2. 当遇到多个构造器使用构建者</h2><p>构造方法和静态工厂共有的限制：不能很好的扩展很多可选参数的场景 。因此对于多个可选参数，考虑使用构建者模式。</p>
<p>其实对于等多个可选参数可以使用新建JavaBean 使用set方法创建实例，这样更通俗易懂但是会很冗长。</p>
<p>builder结合了构造方法的安全性和JavaBean 模式的可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span>      <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span>           <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="built_in">this</span>.servings    = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> val)</span> &#123; </span><br><span class="line">            calories = val;      </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> val)</span> &#123; </span><br><span class="line">           fat = val;           </span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        servingSize  = builder.servingSize;</span><br><span class="line">        servings     = builder.servings;</span><br><span class="line">        calories     = builder.calories;</span><br><span class="line">        fat          = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保多个参数的不变性不受攻击，可以在builder复制参数后对对象属性进行检查。检查失败抛出非法参数异常（IllegalArgumentException）。</p>
<p>单个builder可以重复使用构建多个不同的对象，对象的参数可以灵活调整，适用多个可选参数。</p>
<p>协变返回类型：一个子类的方法被声明为返回在父类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。（这个比较有意思）</p>
<h2 id="3-使用私有构造器或者枚举实现单例"><a href="#3-使用私有构造器或者枚举实现单例" class="headerlink" title="3. 使用私有构造器或者枚举实现单例"></a>3. 使用私有构造器或者枚举实现单例</h2><p>单例对象通常表示无状态，不可变对象。</p>
<p>实现单例的几种方式，其中枚举方式最佳，无偿提供了序列化机制，防止多个实例化。可以阻止反射创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式的实现方式一 Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="comment">// 公共静态成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式的实现方式二 Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 每次调用该方法否返回同一个对象引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式的实现方式三 Enum singleton - the preferred approach（最佳方式）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">     <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化过程中为了保证单例不被破坏，生命所有的字段为transient，并提供readResolve方法。否则当序列化实例被反序列化时，就会创建一个新的实例。</p>
<h2 id="4-使用私有构造器实现非实例化"><a href="#4-使用私有构造器实现非实例化" class="headerlink" title="4. 使用私有构造器实现非实例化"></a>4. 使用私有构造器实现非实例化</h2><p>试图通过创建抽象类来实现非实例化是行不通的，因为该类的子类可以被实例化，并且他还可能会误导用户该类是为了继承而设计的。因此使用简单的方式——私有化构造函数实现类的非实例化。</p>
<h2 id="5-依赖注入优于硬链接资源"><a href="#5-依赖注入优于硬链接资源" class="headerlink" title="5. 依赖注入优于硬链接资源"></a>5. 依赖注入优于硬链接资源</h2><p>当多个类依赖于同一个或者多个底层资源时，静态工具和单例模式对于这种场景是不适用的。因为这两种方式再并发场景中变得不可用，更容易出错。</p>
<p>其实每个实例在使用客户端的资源时，可以在创建时将资源的参数传入构造函数中，这就是依赖注入的一种形式（构造方法注入）。这种方式保证了资源的不可变性，依赖注入不仅适用于构造器，也同样适用于静态工厂和Builder。Supplier<T>这个接口就可以很好的标识这些工厂，客户端传入一个工厂，工厂负责创建指定类型的实例。</T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如生成马赛克的工厂</span></span><br><span class="line">Mosaic <span class="title function_">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入可以大幅度提升类的灵活性，可测试性，复用性。</p>
<h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6. 避免创建不必要的对象"></a>6. 避免创建不必要的对象</h2><p>如果一个对象是不可变的，那么他总能被复用，复用相比于新建更快速。</p>
<p>当不可变类同时提供了构造器和静态工厂方法时，优先使用静态方法来避免创建不必要对象。</p>
<p>自动装箱可能会创建不必要的对象，他模糊了基本类型和装箱类型之间的区别，但是没有消除这种区别，有可能会导致一些性能问题，因此优先使用基本类型而不是装箱类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        <span class="comment">// Long =&gt; long</span></span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意相比于创建新对象，复用的代价更高，如果没能暴增拷贝安全，将会导致潜在的bug和安全漏洞。</p>
<h2 id="7-消除过时的对象引用"><a href="#7-消除过时的对象引用" class="headerlink" title="7. 消除过时的对象引用"></a>7. 消除过时的对象引用</h2><p>内存泄漏：指程序再申请内存后，无法释放已申请的内存空间，内存泄漏堆积后就会发生内存溢出。</p>
<p>内存溢出：报错OOM，没有足够的内存供申请者使用。</p>
<p>一般来讲当一个类自己管理自己的内存时，程序员就要注意内存内存泄露问题了，只要一个元素被释放了，那这个元素包含的所有对象应用都应该被清空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// Eliminate obsolete reference help gc</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消除过期引用的最佳方式是将每个变量定义在最小的作用域中。</p>
<p>缓存是内存泄漏的另一个来源。当将一个对象放到缓存中取，时间长了很容易忘记他还在那，剞劂方法可以使用WeakHashMap来充当缓存，只要key过期后就会被自动清除。</p>
<h2 id="8-避免使用终结方法和清理方法"><a href="#8-避免使用终结方法和清理方法" class="headerlink" title="8. 避免使用终结方法和清理方法"></a>8. 避免使用终结方法和清理方法</h2><p>在Java9中，finalizers方法已经过时了，替代的是清理方法，清理方法比终结方法危险性更低，但仍然是不可预测的，性能比较低，并且也是非必要不使用。</p>
<p>不使用的原因：</p>
<ul>
<li>终结方法和清理方法的缺点在于不能保证被及时执行或会被执行，当一个对象变得不可达，到执行终结方法或清理方法时，这个时间段是任意长的。因此当有对时间要求的任务不应该调用终结或清理方法完成，不应该依赖终结方法或者清理方法来更新重要的持久态。</li>
<li>终结方法的另一个问题是在终结过程中会忽略掉抛出的异常，并且不会打印线程终止的堆栈信息。如果另一个线程企图使用这种未捕获异常的对象可能会发生不确定的行为。</li>
<li>终结方法和清理方法会严重影响性能。</li>
</ul>
<p>清理方法和终结方法的两种用途：</p>
<ol>
<li>当对象的持有者忘记调用终止方法的情况下充当安全网。如 FileInputStream、FileOutputStream、ThreadPoolExecutor、和 java.sql.Connection具有充当安全网终结方法。</li>
<li>本地对灯体是普通对象通过本机方法委托的非Java对象，因为本地对等体不是普通Java对象，因此垃圾收集器不会识别它，当性能可接受且本地对等体没有关键的资源，则可以用清理或者终结方法回收。</li>
</ol>
<h2 id="9-使用try-with-resources代替try-finally"><a href="#9-使用try-with-resources代替try-finally" class="headerlink" title="9. 使用try-with-resources代替try-finally"></a>9. 使用try-with-resources代替try-finally</h2><p>Java中有许多必须通过调用close方法手动关闭的资源，比如InputStream,OutputStream.</p>
<p>在之前，即使是程序抛出异常或者返回的情况下，try-finally是保证资源正确关闭的最佳方式。但是当处理多个资源关闭时，情况就会变糟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">                out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span>   <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst)) &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">            out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，当最里层的finally的close方法关闭失败，外层的的异常就会覆盖掉里层的异常，导致调试过程会很困难。但使用try-with-resourses就可以避免这个问题，并且try-with-resourses代码更加简洁易读。</p>
<h1 id="第二章-所有对象都通用的方法"><a href="#第二章-所有对象都通用的方法" class="headerlink" title="第二章 所有对象都通用的方法"></a>第二章 所有对象都通用的方法</h1><h2 id="10-覆盖equals方法时请遵守通用约定"><a href="#10-覆盖equals方法时请遵守通用约定" class="headerlink" title="10. 覆盖equals方法时请遵守通用约定"></a>10. 覆盖equals方法时请遵守通用约定</h2><p>因为Object主要是为继承设计的，它的所有非final方法都有清晰地约定，任何类要重写这些方法时，都有义务去遵守这些约定否则其他依赖这些约定的类就不会正常工作。</p>
<p>什么时候不需要覆盖equals方法？</p>
<ul>
<li>每个类的实例都是固有唯一的。如Thread</li>
<li>类不需要提供逻辑相等的功能。</li>
<li>父类已经重写过equals方法，父类的行为完全适合子类。</li>
<li>类是私有的，并且equals方法永远不会被调用。</li>
</ul>
<p>什么时候需要重写equals方法？</p>
<p>如果一个类需要一个逻辑相等的概念，并且父类没有重写过这个方法，需要在该类中重写equals方法。通常这种类是值类。如Integer，String。</p>
<p>重写equals方法必须遵守的约定。</p>
<ol>
<li>自反性：对任何费控引用x,x.equals(x)必须返回true。</li>
<li>对称性：对于任何非空引用x和y，如果y.equals(x)=true，则x.equals(y)=true</li>
<li>传递性: x,y,z都不为null，如果x.equals(y)=true，y.equals(z)=true，则z.equals(x)=true。</li>
<li>一致性：如果x,y非空，并且equals比较中的信息没有修改，多次调用x.equals(y)都要始终返回true或false。</li>
<li>对任何非空引用x,x.equals(null)必须返回false。</li>
</ol>
<p>重写equals方法时，要重写hashCode方法，不要让equals方法干太多事，不要将Object参数类型替换成其他类型。</p>
<h2 id="11-重写equals方法时总要重写hashCode"><a href="#11-重写equals方法时总要重写hashCode" class="headerlink" title="11. 重写equals方法时总要重写hashCode"></a>11. 重写equals方法时总要重写hashCode</h2><p>重写equals方法必须重写hashCode方法，如果没有重写，在使用HasMap或HashSet时无法正常运作。</p>
<p>重写的equals方法必须遵守 Object 中指定的规定。</p>
<ul>
<li>在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode 方法都必须始终如一地返回相同的值。</li>
<li>如果两个对象调用 equals（Object）方法比较是相等的，那么调用这两个对象中任意一个对象的 hashCode 方法都必须产生相同的整数结果。</li>
<li>如果两个对象根据 equals（Object）方法比较是不相等的，那么调用这两个对象中任意一个对象的 hashCode 方法，则不一定要产生不同的结果。无论如何，开发者应该知道，不相等的对象产生截然不同的结果，有可能提高散列表（hash tables）的性能。</li>
</ul>
<h2 id="12-始终覆盖toString"><a href="#12-始终覆盖toString" class="headerlink" title="12. 始终覆盖toString"></a>12. 始终覆盖toString</h2><p>默认的Object的toString方法返回的是：类名+@+无符号16进制散列码。</p>
<p>toString 方法应该返回对象中包含的所有值得关注的信息。</p>
<p>在实现toString时，需要判断是否处理返回值的格式。</p>
<ul>
<li>指定字符串的格式的好处：更易读。</li>
<li>指定字符串的格式的坏处：一旦被广泛使用，必须始终坚持这种格式。如果改变格式，将会破坏代码和数据。</li>
</ul>
<p>无论是否指定格式，<strong>都为 toString 返回值中包含的所有信息，提供一种编程式的访问路径。否则不得不自己去解析，解析过程可能会出错。</strong></p>
<h2 id="13-谨慎覆盖clone"><a href="#13-谨慎覆盖clone" class="headerlink" title="13. 谨慎覆盖clone"></a>13. 谨慎覆盖clone</h2><p>假设我们需要为一个类实现Cloneable接口，这个类的父类提供了一个良好的clone方法。我们从super.clone中得到的对象将会是原始对象的一个完整克隆。类中声明的任一属性的值将会和原始类对应的属性的值相等。如果每个属性包含了基本类型值或者不过变对象的引用，那么返回的对象可能正是我们要的，在这种情况下，不需要进一步的处理。</p>
<p>如果一个类它的所有父类获取clone的对象是通过调用super.clone，那么<em>x.clone().getClass() == x.getClass()。</em></p>
<p>对于不可变的类不应该提供clone方法，因为这会造成无意义的拷贝。对于final修饰的属性，克隆不会成功因为禁止向final修饰的属性二次赋值。</p>
<p><strong>实际上，clone方法就是另一个构造器，我们必须保证它不会破坏原始对象而且能恰当创建被克隆对象的约束条件。</strong></p>
<h2 id="14-考虑是否实现comparable"><a href="#14-考虑是否实现comparable" class="headerlink" title="14. 考虑是否实现comparable"></a>14. 考虑是否实现comparable</h2><p>compareTo方法并没有在Object里被声明，而是在Comparable接口中声明的唯一方法。</p>
<p>假如一个类实现了Comparable接口，那就表明了这个类的各个实例之间是有顺序的。几乎所有的Java类库，包括枚举类型（条目34），都实现了Comparable接口。</p>
<p>在下面的表述中，符号sgn（expression）表示数学中的signum函数，返回值为-1，0，1。</p>
<ul>
<li>实现类必须确保对于所有的x和y，sgn(x.compareTo(y)) == -sgn(y. compareTo(x))成立。（这意味着，当且仅当y.compareTo(x)抛出了异常，x.compareTo(y)也必须抛出异常。）（自反性）</li>
<li>实现类必须确保关系的传递性：若(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)，则x.compareTo(z)&gt;0。</li>
<li>最后，实现类必须确保若x.compareTo(y) == 0，则对于所有的z，sgn(x.compareTo(z)) == sgn(y.compareTo(z))成立。（一致性）</li>
<li>强烈建议(x.compareTo(y) == 0) == (x.equals(y))成立，但这并不是必须的，通常来说，任何实现了Comparable接口的类如果违反了这个条件，那么应该做个说明。推荐的说法是“注意：该类具有自然排序，但是与equals方法不一致。”</li>
</ul>
<p>当遇到不同类型的实例比较时，会抛出ClassCastException异常。</p>
<p>在compareTo方法里，我们对属性进行比较是为了得到一个顺序而不是看其是否相等。为了比较对象引用的属性，我们可以递归地调用compareTo方法。如果一个属性没有实现Comparable接口或者我们需要一个非标准的顺序，可以使用Comparator来替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">.thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class="line">.thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhoneNumber pn)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> COMPARATOR.compare(<span class="built_in">this</span>, pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareTo或compare方法依赖于两个值之间的差值，若第一个值小于第二个值，则为负，若两个值相等，则为0，若第一个值大于第二个值，则为正。在实现compareTo方法时，避免使用 &lt; 和 &gt; 运算符来进行属性值的比较。相反，我们应该使用封箱基本类型的静态比较方法（例如Integer.compare），或者Comparator接口里的比较器构造方法（例如Comparator<Object> hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());）。</Object></p>
<h1 id="第三章-类和接口"><a href="#第三章-类和接口" class="headerlink" title="第三章 类和接口"></a>第三章 类和接口</h1><h2 id="15-最小化类和成员的访问性"><a href="#15-最小化类和成员的访问性" class="headerlink" title="15. 最小化类和成员的访问性"></a>15. 最小化类和成员的访问性</h2><p>封装：尽量让每个类或者成员尽可能的不可访问。</p>
<p>如果一个顶层的类或者接口的访问修饰符是private，那么后续你可以修改，替换甚至删除他，而不必担心损害现有的方法，如果是public就需要永远支持，保证兼容性。</p>
<p>如果想要测试代码，需要访问一个类的方法，将private-&gt;default是可接受的，但是提高到更高的访问级别是不可接受的。</p>
<ul>
<li>public类中的成员变量尽量不应该也是public。</li>
<li>对于公有静态常量命名通常是大写字母组成，单词之间通过下划线分开。</li>
<li>让一个类具有共有静态数组，或者返回这种数组的方法是不可取的，因为客户端调用时可以随意修改数组的内容是一个安全漏洞。（确保被公有静态final域引用的对象是不可变的）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 可以改为如下,public -&gt; private 同时添加公有不可变的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)) ;</span><br></pre></td></tr></table></figure>

<h2 id="16-在公有类中使用访问方法而不是公有域"><a href="#16-在公有类中使用访问方法而不是公有域" class="headerlink" title="16. 在公有类中使用访问方法而不是公有域"></a>16. 在公有类中使用访问方法而不是公有域</h2><ul>
<li>公有类应该永远都不要暴露可变域。因为在暴漏之后如果想要更改数据域的字段时就会牵一发而动全身。（客户端代码已经在各处使用了）</li>
<li>对于公有类暴露不可变域的情况，虽然危害小一些，但也仍是有问题的。</li>
<li>如果一个类在包外可以被访问，就应该提供访问方法</li>
</ul>
<h2 id="17-可变性最小化"><a href="#17-可变性最小化" class="headerlink" title="17. 可变性最小化"></a>17. 可变性最小化</h2><p>不可变类的好处：更安全，不容易出错，容易使用。（如String,BigDecimal等）</p>
<ol>
<li>不可变对象天然是线程安全的，不要求同步，不可变对象可以被自由共享，通常也是被static修饰的。</li>
<li>不可变对象为其他对象提供了大量的构件，可以作为map的key,集合的元素，不会破坏考核或者map这种不变性.</li>
<li>不可变对象提供了免费的失败原子机制。状态不会出现临时的不一致性。</li>
</ol>
<p>实现不可变类遵循的几个规则：</p>
<ol>
<li>不提供修改对象状态的方法。如setter</li>
<li>确保这个类不能被继承。用final修饰，阻止子类改变对象的状态，从而破坏不可变性。</li>
<li>所有数据域设置为private final，一个实例在线程之间传递确保正确，并防止对象被修改。</li>
<li>确保对任务可变组件的互斥访问。</li>
</ol>
<p>缺点是：对于大对象来讲，每个不同的值都需要一个对应的对象。创建对象的成本会很高。</p>
<p>解决方法：</p>
<ol>
<li>对于创建中重复的步骤，可以用基本数值类型来代替，这样不用每个步骤创建一个对象。</li>
<li>创建一个公有的伙伴类，类似于String和StringBuilder的关系。</li>
</ol>
<p>注意：如果不可变类实现了序列化接口，同时不可变类还包含了对个指向可变对象的引用，这时候需要显示提供一个readObject方法和readResolve方法，不然攻击者可以通过反序列化方式创建该类的可变实例。</p>
<p>不要每写一个getter就要冲动着去写一个对应的setter。<strong>类应该都是不可变的，除非有个很好的理由需要它们是可变的，如果一个类不能做成不可变，那就尽可能限制它的可变性。这样可以减少出现的错误。</strong></p>
<p><strong>构造器应该完全初始化对象，并建立好不变性。</strong>除非有很强的理由，否则不要在构造器或静态方法之外还提供公有初始化方法。</p>
<h2 id="18-组合优于继承"><a href="#18-组合优于继承" class="headerlink" title="18. 组合优于继承"></a>18. 组合优于继承</h2><p>继承是复用代码的方式，但同时也违反了封装原则。子类需要依赖父类的实现来实现自己的功能。如果父类产生变化，子类将会被破坏，需要跟着父类一起演化。</p>
<p>继承只适用于一个类的类型的确是某个父类的子类型的情况。换句话说，只有当类B和类A是“is-a”的关系时，类B才应该扩展类A。是否每个B都确实是一个A？如果你对这个问题无法肯定地回答yes，那么B就不应该扩展A。</p>
<p>如果子类在一个与父类不同的包中且父类本来就不是设计来被继承的，那么继承将会导致子类的脆弱性。为了避免这种脆弱性，我们应该使用组合与转发，而不是继承，尤其是存在一个适当的接口来实现一个现存的包装者类。包装者类不仅比子类更健壮，而且更强大。</p>
<h2 id="19-要么涉及继承提供文档，要么禁止继承"><a href="#19-要么涉及继承提供文档，要么禁止继承" class="headerlink" title="19. 要么涉及继承提供文档，要么禁止继承"></a>19. 要么涉及继承提供文档，要么禁止继承</h2><p>一个类的文档必须说明在哪些情况下它会调用可子类的覆盖方法。例如，调用可能来自后台线程或者静态初始器。</p>
<p>文档明确说明覆盖迭代方法将会产生的影响，描述方法是怎么做的。这便是继承复杂的一点。</p>
<p>测一个被继承类的唯一方式是编写子类，如果忽略某个保护成员，就会出现问题，在子类中暴漏出来。</p>
<p>如果一个了类允许被继承，必须有约束条件需要遵循。</p>
<ol>
<li>构造函数中一定不要调用可覆盖的方法。否则会导致程序失败。</li>
<li>如果决定让设计被继承的类实现Serializable接口，而且这个类拥有readResolve方法或writeReplace方法，你一定要把readResolve方法或writeReplace方法设为受保护的，而不是私有的。</li>
</ol>
<p>如果某个类的确是要被子类化，否则最好将类声明为final或者保证其没有可访问的构造器来禁止该类被继承。</p>
<h2 id="20-接口优于抽象类"><a href="#20-接口优于抽象类" class="headerlink" title="20. 接口优于抽象类"></a>20. 接口优于抽象类</h2><p>有两种方式可以定义一个多实现的接口：接口和抽象类；</p>
<p>因为Java只允许单继承，所以约束了抽象类作为类型定义的使用，但是接口可以被任意一个类所实现，不管类处于那个位置。</p>
<p>现有类可以很容易实现一个新接口，但是想要扩展一个相同的抽象类只能通过继承的方式，但是这种方式会带来较大的负面影响，强迫所有后代类都继承这个父类无论合不合适。</p>
<p>使用包装类可以安全的增强接口的功能，如果使用抽象类除了继承别无他法。</p>
<p>接口和抽象类可以搭配使用，接口中定义最基础的方法，抽象类实现这些基本的方法，其他子类可以选择是否继承这个抽象类，也可以选择实现最顶层的接口。这样更加灵活。例如Map.Entry的实现，因为接口中不能重写Object的equals和hashcode方法，所以这两种最基本的方法交给抽象类实现。</p>
<h2 id="21-为后代设计接口"><a href="#21-为后代设计接口" class="headerlink" title="21. 为后代设计接口"></a>21. 为后代设计接口</h2><p>Java8中添加了默认方法，目的是为了可以将方法加入现有的接口，但是在现有接口里添加的新方法是充满风险的。</p>
<p>在Java 8里，很多新的默认方法都被加入核心的集合接口里，这主要是为了促进lambda表达式的使用。</p>
<p>因为在接口中加入默认方法虽然可以通过编译但是在运行时可能会出错，这种事件不常有但是并不是不存在。因此应该避免在接口中添加新的default方法。如果必须要添加的话，需要考虑现有的实现类是否会收到影响。</p>
<h2 id="22-接口只用于定义类型"><a href="#22-接口只用于定义类型" class="headerlink" title="22. 接口只用于定义类型"></a>22. 接口只用于定义类型</h2><p>当类实现接口时，该接口作为实现类实例的引用。有种接口不符合这种目的，即常量接口，这种接口不包方法，只有静态final常量。</p>
<p>常量接口的缺点：</p>
<p>实现这个常量接口的实现类会泄露这些细节，这个类的子类的命名空间都会被接口的常量污染。</p>
<p>如果想要导出常量，有两种合适的方式。</p>
<ol>
<li>将这些常量添加到类或者相关的接口里。</li>
<li>新增枚举类型来导出这些常量。</li>
<li>这些常量放在不可初始化的工具类里面。</li>
<li>总之，接口应该只被用来定义类型。它们不能仅仅是用来导出常量。</li>
</ol>
<h2 id="23-类层次优于标签类"><a href="#23-类层次优于标签类" class="headerlink" title="23. 类层次优于标签类"></a>23. 类层次优于标签类</h2><p>标签类和类的层次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Shape</span> &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line">    <span class="comment">// Tag field - the shape of this figure</span></span><br><span class="line">    <span class="keyword">final</span> Shape shape;</span><br><span class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></span><br><span class="line">    <span class="type">double</span> length;</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    <span class="comment">// Constructor for circle</span></span><br><span class="line">    Figure(<span class="type">double</span> radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Constructor for rectangle</span></span><br><span class="line">    Figure(<span class="type">double</span> length, <span class="type">double</span> width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">            <span class="keyword">case</span> RECTANGLE:</span><br><span class="line">                <span class="keyword">return</span> length * width;</span><br><span class="line">            <span class="keyword">case</span> CIRCLE:</span><br><span class="line">                <span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Class hierarchy replacement for a tagged class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> radius;</span><br><span class="line">    Circle(<span class="type">double</span> radius) &#123; </span><br><span class="line">        <span class="built_in">this</span>.radius = radius; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> Math.PI * (radius * radius); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> width;</span><br><span class="line">    Rectangle(<span class="type">double</span> length, <span class="type">double</span> width) &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该避免标签类，标签类中有标签域，Switch语句，如果想要添加新的标签，必须在Switch语句中加case分支，否则会运行失败，标签类太过冗长并且不易阅读，出错率高。</p>
<p>我们可以将标签类转化为类层次的结构。</p>
<p>通过抽象出公有的标签值的方法。让每个子类继承抽象类，定义自己特有的数据域。</p>
<p>类层次的优点是，提高了代码的灵活性，清晰的展示了类之间的层次关系，并且可进行更好的变异检查。</p>
<h2 id="24-静态成员类优于非静态成员类"><a href="#24-静态成员类优于非静态成员类" class="headerlink" title="24. 静态成员类优于非静态成员类"></a>24. 静态成员类优于非静态成员类</h2><p>嵌套类是为了服务它所在的外围类。如果一个嵌套类还可以用于其他地方，那么应该单独放一个源文件里。</p>
<p>嵌套类的种类：静态成员类，非静态成员类，匿名内部类，局部类。</p>
<p>静态成员类：可以声明再其他类的内部，并且可以访问外围的所有成员变量。通常用法是和外围的类一块使用处理简单逻辑。</p>
<p>非静态成员类：不被static修饰的成员类，非静态实例被创建时就与外部类关联，并且关联后不可修改。常被用来定义适配器，例如Set,List中通过非静态成员类实现他们自己的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; &#123;</span><br><span class="line">... <span class="comment">// Bulk of the class omitted</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyIterator</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果你声明了一个不需要访问外围实例的成员类，那你总是应该static修饰符加到声明里去</strong>，使得这个成员类是静态的。如果你不加这个修饰符，那么每个实例都将包含一个隐藏的外围实例的引用。更严重的是，当这个外围实例已经满足垃圾回收的条件时，非静态成员类实例会导致外围实例被保留。因此而导致的内存泄露是灾难性的。</p>
<p>匿名类：不是外围类的成员，没有名字，在代码任意一个表达式合法的地方，匿名类都可以使用。匿名类使用的限制：在声明之后无法再初始化，并且不能通过instanceof测试或者指定类名的操作，匿名类必须简短，否则会影响可读性。匿名类的另一个用法是实现静态工厂方法。lambda表达式出现后，创建小的函数对象通常首选lambda。</p>
<h2 id="25-限制源文件为单个顶级类"><a href="#25-限制源文件为单个顶级类" class="headerlink" title="25. 限制源文件为单个顶级类"></a>25. 限制源文件为单个顶级类</h2><p>永远不要将多个顶级类或接口放到一个源文件里。遵守这条规则就能保证在编译时不会遇到一个类有多个定义的情况。这又保证了编译产生的class文件和随之产生的程序行为不会依赖于传给编译器的源文件顺序。</p>
<p>程序的行为受传递给编译器的源文件顺序的影响，这是无法接受的。</p>
<p>解决方法那就是将这些顶级类分别写到各自的源文件里去。如果你尝试将多个顶级类放入同一个源文件，可以考虑使用静态成员类（条目）作为将不同类拆分为单独源文件的替代办法。</p>
<p>如果某些类是为其他类提供服务的，那么将这些类声明为静态私有成员类，这样可以减少类的可访问性，并且增强可阅读性。</p>
<h1 id="第四章-泛型"><a href="#第四章-泛型" class="headerlink" title="第四章 泛型"></a>第四章 泛型</h1><h2 id="26-不要使用原始类型"><a href="#26-不要使用原始类型" class="headerlink" title="26. 不要使用原始类型"></a>26. 不要使用原始类型</h2><p>泛型类型：接口和泛型类</p>
<p>泛型类型都定义了一组参数化的类型，如List<String> 表示元素是String类型的列表。</String></p>
<p>不应该使用原始类型，如List list = new ArrayList();</p>
<p>这样做如果加入的对象类型不一样虽，然可以通过编译，但是运行时会报错ClassCastException异常异常；应该使用参数化类型，这样在编译期间就可以发现错误，更加安全。</p>
<p>无限制通配符类型：Set&lt;?&gt;（读作，某些类型的集合），他和原始类型的区别是，通配符类型更加安全，当你讲任意非null得元素放入集合总，就会产生编译时错误。</p>
<p>原始类型被提供仅是为了兼容性以及能与引入泛型之前的遗留代码互用。</p>
<p>原始类型可以用在以下两种情况：</p>
<ol>
<li>List.class,Set.class,</li>
<li>if(o instanceof Set)</li>
</ol>
<h2 id="27-消除未检查警告"><a href="#27-消除未检查警告" class="headerlink" title="27. 消除未检查警告"></a>27. 消除未检查警告</h2><p>如果你无法消除某个警告，但是这个警告的代码是安全的，可以使用@SuppressWarnings(“unchecked”)注解来禁止这个警告。</p>
<p>SuppressWarnings注解可以声明在局部变量，方法，类上，但是应该尽可能的在小的作用域使用。每次使用这个注解应该加上注释，说明类型转换是安全的，可以帮别人理解这段代码。</p>
<p>每个未检查警告都表示可能在运行时出现ClassCastException异常，所以不要忽视他们。</p>
<h2 id="28-列表优先于数组"><a href="#28-列表优先于数组" class="headerlink" title="28. 列表优先于数组"></a>28. 列表优先于数组</h2><p>数组与列表的区别:</p>
<p>协变性：如果Sub是Super的一个子类型，那么数组类型Sub[]也是数组类型Super[]的子类型。</p>
<p>可具化：在运行时才知道并检查元素类型。</p>
<p>数组是协变的并可具化的；泛型是受约束并且可擦除的。因此，数组提供了运行时类型安全性但不保证编译时类型安全性，泛型则反过来。通常，数组和泛型不能很好混用.</p>
<p>数组在运行时才去检查元素的类型，如果将一个String加入Long的数组里，会抛出一个ArrayStoreException；泛型是在编译期间去检查的，运行时会擦除元素类型，泛型擦除使得泛型类型可以自由与从未使用过泛型的代码互相调用。因此使用泛型列表可以尽早发现错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  generic array creation is illegal - won&#x27;t compile</span></span><br><span class="line">List&lt;String&gt;[] stringLists = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">1</span>]; <span class="comment">// (1)</span></span><br><span class="line">List&lt;Integer&gt; intList = List.of(<span class="number">42</span>); <span class="comment">// (2)</span></span><br><span class="line">Object[] objects = stringLists; <span class="comment">// (3)</span></span><br><span class="line">objects[<span class="number">0</span>] = intList; <span class="comment">// (4)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// (5)</span></span><br></pre></td></tr></table></figure>

<p>为了尽可能避免出现泛型数组创建错误或者未检查异常，最好优先使用集合类型，它更安全。</p>
<h2 id="29-优先考虑使用泛型类"><a href="#29-优先考虑使用泛型类" class="headerlink" title="29. 优先考虑使用泛型类"></a>29. 优先考虑使用泛型类</h2><p>与强制转换类型相比，泛型更方便和安全，这通常意味着设计更加通用，客户端代码不用强制转换类型就可以使用泛型类的方法。</p>
<h2 id="30-优先考虑使用泛型方法"><a href="#30-优先考虑使用泛型方法" class="headerlink" title="30. 优先考虑使用泛型方法"></a>30. 优先考虑使用泛型方法</h2><p>Collections类的所有“算法”方法（如binarySearch方法和sort方法）都是泛型的。</p>
<p>常用泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union s1 s2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> &#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型单例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; UnaryOperator&lt;T&gt; <span class="title function_">identityFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (UnaryOperator&lt;T&gt;) IDENTITY_FN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归类型限制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意能和自身比较的类型E</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; E <span class="title function_">max</span><span class="params">(Collection&lt;E&gt; c)</span>;</span><br></pre></td></tr></table></figure>

<p>应该保证你的方法不用客户端强转就能用，这意味着要将这些方法泛型化，你也应该将现有方法泛型化，让新用户用起来更简单，而且不用破坏现有客户端。</p>
<h2 id="31-使用有限制通配符来增加API灵活性"><a href="#31-使用有限制通配符来增加API灵活性" class="headerlink" title="31. 使用有限制通配符来增加API灵活性"></a>31. 使用有限制通配符来增加API灵活性</h2><p>通配符类型：&lt;? super E&gt;, &lt;? extend E&gt;</p>
<p>使用通配符的基本原则：PESC，一个参数化类型表示T类型的生产者，用&lt;? extend E&gt;；如果一个参数化类型代表一个T类型的消费者，则使用&lt;? super T&gt;。GET和PUT 原则。</p>
<p>通配符如果使用得当，对使用者来讲通配符的添加几乎是不可见的，通配符使得这些方法应该接收哪些参数，拒绝哪些参数。</p>
<p>返回类型不要用限制的通配符。因为这样强制客户端使用通配符类型。</p>
<h2 id="32-合理结合泛型和变长参数"><a href="#32-合理结合泛型和变长参数" class="headerlink" title="32. 合理结合泛型和变长参数"></a>32. 合理结合泛型和变长参数</h2><p>可变长参数的目的是为了允许客户端可以在方法里传入数量可变的参数，当你调用一个变长参数方法时，一个数组就会被创建，并用来存储这些参数，当变长参数是泛型类型或者参数化类型时，会得到编译器警告。</p>
<p>@SafeVarargs注解表示允许可变参数的方法使用泛型，并且禁止警告。除非确定了使用是安全的，否则不要使用这个注解。并且这个注解只对不重写的方法时合法的，Java8中仅仅对静态方法和final实例方法合法。</p>
<p>泛型可变参数是安全的情况：</p>
<ol>
<li>不在可变参数数组中存储数据</li>
<li>对外部代码不可见。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&lt;T&gt;List&lt;T&gt;pickTwo(Ta,Tb,Tc)&#123;</span><br><span class="line"><span class="keyword">switch</span>(rnd.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> List.of(a, b);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> List.of(a, c);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> List.of(b, c);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(); <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">  List&lt;String&gt; attributes = pickTwo(<span class="string">&quot;Good&quot;</span>, <span class="string">&quot;Fast&quot;</span>, <span class="string">&quot;Cheap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-考虑类型安全的异构容器"><a href="#33-考虑类型安全的异构容器" class="headerlink" title="33.考虑类型安全的异构容器"></a>33.考虑类型安全的异构容器</h2><p>泛型在容器中通常用法限制了每个容器类型参数的数量，可以使用Class对象作为类型安全异构容器的key，value是对应参数类型，以这种方式使用的Class对象被叫做类型令牌。</p>
<p>Favorites类称为类型安全的异构容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Favorites</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  	<span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> &#123;</span><br><span class="line">    	favorites.put(type, type.cast(instance));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">cast</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-枚举和注解"><a href="#第五章-枚举和注解" class="headerlink" title="第五章 枚举和注解"></a>第五章 枚举和注解</h1><h2 id="34-用枚举替换常量"><a href="#34-用枚举替换常量" class="headerlink" title="34.用枚举替换常量"></a>34.用枚举替换常量</h2><p>枚举类型（enum type）是指由一组固定的常量组成合法值的类型。在java 还没有引入枚举类型之前，通常使用int具名常量表示（如四季，月份，花色等）。</p>
<p>Java枚举本质上是int值。枚举是单例的泛型化，是受控制的，每个数据都是final的，枚举还允许添加任意的方法和域，并实现任意的接口，提供了Object的所有方法，实现了Comparable和Searializable，并针对枚举类型的可任意改变性设计了序列化方式。</p>
<p>枚举中的抽象方法必须被他所有常量中的具体方法覆盖。</p>
<p>什么时候可以使用枚举？</p>
<p>只要是在编译时已知的常量就可以使用枚举来代替。</p>
<p>枚举相比于int常量的优点：更好的可读性，安全性，更加强大，如果有多个枚举值同时有共享的行为，考虑使用策略枚举。</p>
<h2 id="35-使用实例域来替换序数"><a href="#35-使用实例域来替换序数" class="headerlink" title="35.使用实例域来替换序数"></a>35.使用实例域来替换序数</h2><p>每个枚举都有一个ordinal方法，他返回每个枚举在类型中的数字位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Ensemble</span> &#123;</span><br><span class="line">    SOLO, DUET, TRIO, QUARTET, QUINTET,</span><br><span class="line">    SEXTET, SEPTET, OCTET, NONET, DECTET;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfMusicians</span><span class="params">()</span> &#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果改变枚举变量中的顺序就会将这些常量重新排序，numberOfMusicians方法就会被破坏。</p>
<p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Ensemble</span> &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPTET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> numberOfMusicians;</span><br><span class="line">    Ensemble(<span class="type">int</span> size) &#123; <span class="built_in">this</span>.numberOfMusicians = size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfMusicians</span><span class="params">()</span> &#123; <span class="keyword">return</span> numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-使用EnumSet替换位域"><a href="#36-使用EnumSet替换位域" class="headerlink" title="36.使用EnumSet替换位域"></a>36.使用EnumSet替换位域</h2><p>位域：使用位运算讲几个常量合并到一个集合中，这个集合就是位域。</p>
<p>当打印输出位域时，很难理解这些常量的含义。所以使用EnumSet来代替。</p>
<p>EnumSet的优点：性能好（removeAll,retainAll方法都是利用位运算实现的），并且枚举更简洁表示含义更清晰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Style</span> &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line">    <span class="comment">// Any Set could be passed in, but EnumSet is clearly best</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用EnumSet.of()</span></span><br><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure>

<h2 id="37-使用EnumMap替换序数索引"><a href="#37-使用EnumMap替换序数索引" class="headerlink" title="37.使用EnumMap替换序数索引"></a>37.使用EnumMap替换序数索引</h2><p>有时会用到Enum.ordinal方法，但是不推荐使用。</p>
<p>例如现在想要列出植物园中一年生，两年生，多年生植物。需要创建集合数组，每个生命周期的植物是一个集合。遍历整个花园的植物将对应生命周期的植物放在对应的集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle =</span><br><span class="line">    (Set&lt;Plant&gt;[]) <span class="keyword">new</span> <span class="title class_">Set</span>[Plant.LifeCycle.values().length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; plantsByLifeCycle.length; i++)</span><br><span class="line">    plantsByLifeCycle[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Plant p : garden)</span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);</span><br><span class="line"><span class="comment">// Print the results</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s: %s%n&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组不兼容泛型，也不知道数组中的索引代表什么，如果使用出错会抛出 ArrayIndexOutOfBoundsException 异常 。</p>
<p>可以使用EnumMap来代替数组的形式。Map的key是植物的生命周期枚举类型，value对应的是这种生命周期的所有植物。其实EnumMap内部就了这样的一个索引数组，只是隐藏操作数组的细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt;  plantsByLifeCycle =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Plant.LifeCycle.class);</span><br><span class="line"><span class="keyword">for</span> (Plant.LifeCycle lc : Plant.LifeCycle.values())</span><br><span class="line">    plantsByLifeCycle.put(lc, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (Plant p : garden)</span><br><span class="line">    plantsByLifeCycle.get(p.lifeCycle).add(p);</span><br></pre></td></tr></table></figure>

<p>总之使用EnumMap来代替索引数组，当出现对象之间的关系是多维的，使用EnumMap&lt;key1, EnumMap&lt;key,2 val&gt;&gt;</p>
<h2 id="38-使用接口来模仿可扩展的枚举"><a href="#38-使用接口来模仿可扩展的枚举" class="headerlink" title="38.使用接口来模仿可扩展的枚举"></a>38.使用接口来模仿可扩展的枚举</h2><p>操作码用例可以使用可伸缩性的枚举类型实现。操作码的元素表示在某种机器上的操作。</p>
<p>定义操作接口，枚举实现这个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emulated extensible enum using an interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BasicOperation</span> <span class="keyword">implements</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS(<span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">        BasicOperation(String symbol) &#123;</span><br><span class="line">        <span class="built_in">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然枚举不能多实现但是，接口支持多实现，可以定义多个枚举实现这个接口。并用新的实现类代替基本类型。</p>
<p>用接口实现可伸缩枚举的不足之处是：枚举不能继承另一个枚举。如果代码不依赖任何枚举的状态，就可以在接口中添加默认实现。java.nio.file.LinkOption 枚举类型实现了 CopyOption 和 OpenOption 接口。</p>
<h2 id="39-注解优先于命名模式"><a href="#39-注解优先于命名模式" class="headerlink" title="39.注解优先于命名模式"></a>39.注解优先于命名模式</h2><p>命名模式：表名一些程序需要通过某种工具或者框架进行特殊处理。</p>
<p>缺点：</p>
<ol>
<li>如果命名出现错误，就不会执行但是也不会报错。</li>
<li>不能确保他们只用在相应的程序元素上。比如有个名字叫TestSafetyMechanisms的类，想要测试这个类中的所有方法，但是Junit3不会执行，因为这个类中的方法名不是test开头的。</li>
<li>命名模式没有提供将参数值将程序元素相关联的方法。</li>
</ol>
<p>JUnit 从第 4 版开始采用@Test注解，解决了以上问题。Test注解只在方法上起作用，不能被用在类上或者其他元素上，否则编译不过。因为Test注解没有参数所以叫做标记注解。注解永远不会改变被注解代码的语义，但是使它可以通过工具进行特殊的处理。</p>
<p>注解的处理是使用反射执行标记了注解的方法，在执行过程中捕获异常并打印日志，还可以获取到注解上的参数，并校验参数类型。注解中的数组参数语法很灵活，指定多元素数组使用{}包裹，并用逗号分隔开。</p>
<h2 id="40-坚持使用Overide注解"><a href="#40-坚持使用Overide注解" class="headerlink" title="40. 坚持使用Overide注解"></a>40. 坚持使用Overide注解</h2><p>@Override注解用户方法声明，表示被注解的方法会覆盖父类的方法，如果坚持使用这个注解，可以防止一大类的非法错误。</p>
<p>比如Bigram类本身想要重写父类Object的hashCode和toString方法，但是因为类型错误，没能覆盖而是重载了equals方法。并且因为没有标注@Overide所以在编译的时候没能发现这个错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can you spot the bug?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bigram</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> second;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bigram</span><span class="params">(<span class="type">char</span> first, <span class="type">char</span> second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数类型应该是Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Bigram b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.first == first &amp;&amp; b.second == second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * first + second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;Bigram&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ch++)</span><br><span class="line">                s.add(<span class="keyword">new</span> <span class="title class_">Bigram</span>(ch, ch));</span><br><span class="line">        System.out.println(s.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-标记接口定义接口类型"><a href="#41-标记接口定义接口类型" class="headerlink" title="41. 标记接口定义接口类型"></a>41. 标记接口定义接口类型</h2><p>标记接口：接口中不包含任何方法声明。例如Serilizable接口。</p>
<p>标记接口比标记注解的两个优点：</p>
<ol>
<li>标记接口定义的类型是可被实例类实现的，但是注解不行。标记接口类型允许在编译时捕获错误但是注释只能在运行时捕获错误。</li>
<li>可以被更加精确的锁定，如果注解类型使用ElementType.TYPE声明，他就表示可以被应用到任何类或者接口。</li>
</ol>
<p>什么时候使用标记注解？</p>
<p>如果标记的不是类和接口，就使用注解。如果标记要应用到类和接口这时候考虑我是否想要编写一个或者多个具有该标记的方法呢？如果是就优先使用标记接口。</p>
<h1 id="第六章-Lambda和Stream"><a href="#第六章-Lambda和Stream" class="headerlink" title="第六章 Lambda和Stream"></a>第六章 Lambda和Stream</h1><h2 id="42-lambda表达式优先于匿名类"><a href="#42-lambda表达式优先于匿名类" class="headerlink" title="42. lambda表达式优先于匿名类"></a>42. lambda表达式优先于匿名类</h2><p>在Java8之前创建函数对象的主要方式是匿名类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(words, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>匿名类适用于需要函数对象的经典面向对象设计模式，尤其是策略模式，比较器接口是排序的抽象策略。</p>
<p>在Java8中引入了函数式接口，允许使用lambda表达式创建这些接口实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(words,</span><br><span class="line">        (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure>

<p>编译器从上下文中根据类型推断推导出这些参数的类型，在某些时候，需要指定参数类型，否则编译器无法确定这些参数类型。</p>
<p>与其他方法和类不同，lambda没有名称和文档；如果计算不是自解释的，或者超过几行，则不要将其放入lambda表达式中，如果lambda表达式太长会影响可读性。</p>
<p>除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。</p>
<h2 id="43-方法引用优于lambda表达式"><a href="#43-方法引用优于lambda表达式" class="headerlink" title="43. 方法引用优于lambda表达式"></a>43. 方法引用优于lambda表达式</h2><p>lambda优于匿名类的主要优点是更加简洁，Java提供了生成函数对象的方法比lambda还要简洁。两者在选用过程中哪个简洁使用哪个。</p>
<table>
<thead>
<tr>
<th><strong>Method Ref Type</strong></th>
<th><strong>Example</strong></th>
<th><strong>Lambda Equivalent</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Static</td>
<td>Integer::parseInt</td>
<td>str -&gt; Integer.parseInt(str)</td>
</tr>
<tr>
<td>Bound</td>
<td>Integer::parseIntr</td>
<td>Instant then = Instant.now(); t -&gt; then.isAfter(t)</td>
</tr>
<tr>
<td>Unbound</td>
<td>String::toLowerCase</td>
<td>str -&gt; str.toLowerCase()</td>
</tr>
<tr>
<td>Class Constructor</td>
<td>TreeMap&lt;K, V&gt;::new</td>
<td>() -&gt; new TreeMap&lt;K, V&gt;</td>
</tr>
<tr>
<td>Array Constructor</td>
<td>int[]::new</td>
<td>len -&gt; new int[len]</td>
</tr>
</tbody></table>
<h2 id="44-优先使用标准的函数式接口"><a href="#44-优先使用标准的函数式接口" class="headerlink" title="44. 优先使用标准的函数式接口"></a>44. 优先使用标准的函数式接口</h2><p>6哥基本的函数式接口</p>
<table>
<thead>
<tr>
<th><strong>Interface</strong></th>
<th><strong>Function Signature</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator</td>
<td>T apply(T t)</td>
<td>String::toLowerCase</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>T apply(T t1, T t2)</td>
<td>BigInteger::add</td>
</tr>
<tr>
<td>Predicate</td>
<td>boolean test(T t)</td>
<td>Collection::isEmpty</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>R apply(T t)</td>
<td>Arrays::asList</td>
</tr>
<tr>
<td>Supplier</td>
<td>T get()</td>
<td>Instant::now</td>
</tr>
<tr>
<td>Consumer</td>
<td>void accept(T t)</td>
<td>System.out::println</td>
</tr>
</tbody></table>
<p>如果基本的函数式接口可以满足你的要求，那应该优先使用它而不是新建功能接口。</p>
<p>Function接口有9个变体，如果源类型和结果类型都是基本类型则使用源类型作为前缀的Function，例如LongToIntFunction，如果源类型是基本类型但是结果类型是引用类型，则使用ToObj前缀的Function，如DoubleToObjFunction。</p>
<p>什么时候考虑编写新的功能接口（Comparator）而不是使用标准接口？</p>
<ul>
<li>该接口将被普遍使用</li>
<li>具有相关的约定</li>
<li>受益于自定义的默认方法</li>
</ul>
<p>其他大部分情况使用Function提供的标准接口。</p>
<h2 id="45-明智地使用streams"><a href="#45-明智地使用streams" class="headerlink" title="45. 明智地使用streams"></a>45. 明智地使用streams</h2><p>流：表示有限或无限的数据元素序列；</p>
<p>流管道：表示对这些元素多阶段的结算</p>
<p>流管道的计算是惰性的，直到调用teminal操作时才开始计算，并且对完成terminal操作不需要的数据元素不会计算。默认情况下流管道按照顺序运行。</p>
<p>流API非常通用，实际上任何计算都可以使用流执行，如果使用得当可以使程序更加简短清晰。使用不当会导致程序难以读取和维护。</p>
<p>lambda表达式的餐胡命名对于流管道的可读性至关重要。</p>
<p>在流管道中使用helper方法比在循环中重要。</p>
<p>在lambda表达式中，只能读取final的变量，不能修改任何局部变量。</p>
<p>flatMap：将流扁平化。将Stream中的每个元素映射到新的流然后关联起来。</p>
<h2 id="46-优先使用Stream无副作用的函数"><a href="#46-优先使用Stream无副作用的函数" class="headerlink" title="46. 优先使用Stream无副作用的函数"></a>46. 优先使用Stream无副作用的函数</h2><p>流管道编程的本质是无副作用的对象，这适用于传递给流和相关对象。foreach方法仅用于输出计算结果，还不适用于执行计算。收集器常见的有，toList，toSet，toMap，groupingBy和join。</p>
<p>养成将collecto()方法中放静态方法的习惯，因为这样可读性更高。</p>
<p>toMap操作如果一个key对应了多个流元素就会抛出IllegalStateException异常来终止。这时候使用三个参数的toMap()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toMap(keyMapper, valueMapper, (v1, v2) -&gt; v2)</span><br></pre></td></tr></table></figure>

<p>当发生冲突，执行第三个参数设置的last-write-wins策略。</p>
<h2 id="47-Stream优先使用Collection作为返回类型"><a href="#47-Stream优先使用Collection作为返回类型" class="headerlink" title="47. Stream优先使用Collection作为返回类型"></a>47. Stream优先使用Collection作为返回类型</h2><p>如果编写一个的方法知道会在流管道中使用，可以返回Stream，类似的如果仅用于遍历序列则可以返回Iterable接口。</p>
<p>Collection是Iterable的子类型，因此可迭代并支持Stream，因此，Collection或者他的子类是返回方法的最佳返回类型。</p>
<p>如果返回的数据量小并且可以放入内存中，那么最好返回标准的集合。如果数据太多，不要作为集合返回。</p>
<h2 id="48-谨慎使用Stream并行"><a href="#48-谨慎使用Stream并行" class="headerlink" title="48. 谨慎使用Stream并行"></a>48. 谨慎使用Stream并行</h2><p>如果源来自 Stream.iterate，或者使用中间操作限制，并行化管道也不太可能提高其性能。所以不要不加选择的使用并行流导致性能灾难。</p>
<p>并行性的性能增益最好是在 ArrayList，HashMap，HashSet 和 ConcurrentHashMap 实例上；int 数组；和 long 数组。因为它们都可以准确且分成任何所需大小的子范围。</p>
<p>这使得在并行线程之间划分工作变得容易。</p>
<p>并行流不仅有可能会导致性能上的问题，还可能导致不正确的结果和不可预测的行为（安全失败）。使用.map,filter其他不规范的功能丰富都可能导致并行的安全出问题。</p>
<p>通常所有的并行流管道都在公共fork-join线程池中运行。单个行为不当的管道流会影响系统中其他不想关的部分。</p>
<p>总之除非使用并行流之后得到的结果是正确的并且相比之前对性能上有预期的提升，否则不应该尝试使用并行的管道流。</p>
<h1 id="第七章-方法"><a href="#第七章-方法" class="headerlink" title="第七章 方法"></a>第七章 方法</h1><h2 id="49-校验参数有效性"><a href="#49-校验参数有效性" class="headerlink" title="49. 校验参数有效性"></a>49. 校验参数有效性</h2><p>大多数方法包括构造方法对于参数值都有某些限制，例如引用类型必须不能为null，数组下标必须大于等于0等。校验参数如果出现错误抛出一个参数校验异常，不在进行后续的操作。</p>
<p>Java7中添加的 Objects.requireNonNull(Object obj, “errorMessage”) 可以校验对象引用不为null，比较灵活。</p>
<p>Java 9 中，范围检查工具被添加到 java.util.Objects 中。该工具由三个方法组成：checkFromIndexSize，checkFromToIndex 和 checkIndex。此工具不如空检查方法灵活。它不允许你自定义异常的详细消息，它仅用于列表和数组索引。</p>
<p>每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来校验这些限制。养成这样的习惯是非常重要的。</p>
<h2 id="50-必要时进行保护性拷贝"><a href="#50-必要时进行保护性拷贝" class="headerlink" title="50. 必要时进行保护性拷贝"></a>50. 必要时进行保护性拷贝</h2><p>对于构造器中的每个参数进行保护性拷贝是必要的的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Repaired constructor - makes defensive copies of parameters</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Period</span><span class="params">(Date start, Date end)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.start = <span class="keyword">new</span> <span class="title class_">Date</span>(start.getTime());</span><br><span class="line">    <span class="built_in">this</span>.end = <span class="keyword">new</span> <span class="title class_">Date</span>(end.getTime());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.start.compareTo(<span class="built_in">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="built_in">this</span>.start + <span class="string">&quot; after &quot;</span> + <span class="built_in">this</span>.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。</p>
<p>例如你正在使用客户端提供的对象引用作为内部Set实例的元素，或者作为内部Map的Key，就应该意识到如果这个对象在插入之后被修改，Map中的约束条件就会被破坏，因此需要对这个对象做保护性拷贝。</p>
<p>保护性拷贝可能会带来性能损失但是也不一定。如果一个类信任他的调用者不会修改内部的组件，可能因为类以及客户端都在同一个包里，那么不进行保护性拷贝也是可以的。</p>
<p>即使不在同一个package下，也并不总是在可变参数整合到对象之前对他进行保护拷贝。</p>
<p>简而言之，如果类具有从客户端得到或者返回给客户端的可变组件，类就必须设计保护性拷贝，如果拷贝的成本收到限制，并且类信任客户端不会错误修改返回的组件，就可以在文档中知名客户端的职责是不得修改收到影响的组件以此代替保护性拷贝。</p>
<h2 id="51-谨慎设计方法签名"><a href="#51-谨慎设计方法签名" class="headerlink" title="51. 谨慎设计方法签名"></a>51. 谨慎设计方法签名</h2><ul>
<li><p>谨慎选择方法名称：方法名称首要目标是易于理解第二个目标是广泛认可的命名。</p>
</li>
<li><p>不要过于追求提供遍历的方法</p>
</li>
<li><p>避免过长的参数列表。参数个数应该小于等于4。</p>
<ul>
<li>缩短参数列表的方法<ul>
<li>将方法拆分成多个方法</li>
<li>创建参数类型保存参数的分组，一般是静态成员类</li>
<li>构建参数对象时使用建造者模式</li>
</ul>
</li>
</ul>
</li>
<li><p>对于参数类型优先使用接口而不是类</p>
</li>
<li><p>对于Boolean类型的参数优先使用枚举类型</p>
</li>
</ul>
<h2 id="52-慎用重载"><a href="#52-慎用重载" class="headerlink" title="52. 慎用重载"></a>52. 慎用重载</h2><p>当一个方法被重载后，调用哪个方法是在编译时决定的。</p>
<p>对于选择哪个重载方法是在编译期决定的，选择被覆盖的方法是在运行时进行的，选择的依据是被调用方法的对象的运行时类型。</p>
<p>覆盖机制满足了人们对于方法调用行为的期望，重载不及期望，因此避免乱用重载机制。</p>
<p>避免重载的方法：不要导出两个具有相同参数数目的重载方法。</p>
<p>一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。当正在改造一个现有的类来实现新的接口就应该保证，当传递同样的参数时，所有的虫子啊方法的行为必须一致，如果不能保证这点，开发者就会不理解为什么不能正常工作。</p>
<h2 id="53-慎用可变参数"><a href="#53-慎用可变参数" class="headerlink" title="53. 慎用可变参数"></a>53. 慎用可变参数</h2><p>可变参数可以接受0个或者多个指定类型的参数，可变参数通过创建一个数组，数组的大小是参数的数量，然后将参数值传递到数组中，最后将数组传给方法。</p>
<p>当需要让一个方法带有不定数量的参数时，可变参数非常有效，在性能要求高的情况下要小心使用可变参数，因为每次调用可变参数方法就会为数组分配内存和初始化。</p>
<h2 id="54-返回空集合或者是数组而不是null"><a href="#54-返回空集合或者是数组而不是null" class="headerlink" title="54. 返回空集合或者是数组而不是null"></a>54. 返回空集合或者是数组而不是null</h2><p>当使用null代替空集合或者数组的返回值的时候就容易出错，因为客户端调用者会忘记处理这个null，从而抛出NPE，返回null容易使你的方法难以维护容易出错，而且没有什么性能上的优势。</p>
<h2 id="55-谨慎返回Optionals"><a href="#55-谨慎返回Optionals" class="headerlink" title="55. 谨慎返回Optionals"></a>55. 谨慎返回Optionals</h2><p>在Java8之前，当有遇到无法返回值的方法时，可以抛出异常或者返回null，但是这两种都不算完美，异常需要额外的代码来处理，需要调用者try-cache处理异常；如果返回null容易出现NullPointException。</p>
<p>Optional类在Java8版本中表示可以持有单个非空引用或者什么都没有的不可变容器。因此当无法给方法返回返回值的时候可以返回一个Optional。</p>
<p>optional可以使用empty()和of(T value)方法创建Optional实例，但是of方法中的入参不能是null，否则会抛出NullPointException。</p>
<p>并不是所有的返回类型都能受益于optional的返回类型。容器类型，包括Collection，map，stream，数组，以及optional都不应该再用optional进行包装了。你应该放回一个空的List，而不是空的Optional<List>。</List></p>
<p>不应该把基本封装类型的Optional作为返回值，应该使用对应的OptionalInt/OptionalLong/OptionalDouble</p>
<p>返回optional的时候，会有性能问题，对于性能要求严格的方法，可能还是返回null或者抛出异常要更好一些。</p>
<h2 id="56-为所有导出的API元素编写文档注释"><a href="#56-为所有导出的API元素编写文档注释" class="headerlink" title="56. 为所有导出的API元素编写文档注释"></a>56. 为所有导出的API元素编写文档注释</h2><p>对API进行合适的文档注释，必须在每个导出的类，接口，构造器，方法，属性字段声明前写文档注释。如果这个类是可序列化的也应该为它的序列化形式编写doc.</p>
<p>为方法编写文档注释时，必须说明这个方法做了什么，而不是具体的实现细节。通过@throw标签抛出方法中uncheckedException。其中@param也为参数设置了前提条件以及含义。@return标签表示该方法的返回值类型以及含义。</p>
<blockquote>
<p>文档注释是将API文档化的最有效的方法。对于所有导出的API元素，应该强制使用文档注释。采用一贯的风格来遵守标准的约定。记住，在文档注释中可以出现任何的HTML标签，但是那些HTML元字符必须进行转义。</p>
</blockquote>
<h1 id="第八章-通用设计"><a href="#第八章-通用设计" class="headerlink" title="第八章 通用设计"></a>第八章 通用设计</h1><h2 id="57-局部变量作用域最小化"><a href="#57-局部变量作用域最小化" class="headerlink" title="57. 局部变量作用域最小化"></a>57. 局部变量作用域最小化</h2><p>将局部变量作用域最小化的有效方法是在第一次使用这个变量时进行声明。如果在使用之前声明，会比较混乱。</p>
<p>如果一个变量在使用方法的外面进行了声明，当程序退出这个块的时候，这个变量还是可见的，如果这个变量在目标方法外使用之前对变量进行了更改就会照成意外的错误。</p>
<p>每个变量的声明都应该立即初始化，如果不确定是否初始化，应该延迟声明直到可以初始化为止。try-cache语句是个例外，如果变量需要在try代码块之外使用，就必须在方法块之前声明。</p>
<p>当循环变量在循环结束之后不再使用的时候，使用for循环优于while循环。</p>
<h2 id="58-for-each优于传统for循环"><a href="#58-for-each优于传统for循环" class="headerlink" title="58. for-each优于传统for循环"></a>58. for-each优于传统for循环</h2><p>增强for循环通过隐藏Iterator和索引变量解决了混乱和可能出现的问题。更加灵活简洁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The preferred idiom for iterating over collections and arrays</span></span><br><span class="line">   <span class="keyword">for</span> (Element e : elements) &#123;</span><br><span class="line">       ... <span class="comment">// Do something with e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强for循环没有什么性能损失，对数组集合都一样。</p>
<p>有三种情况下不能使用增强for循环</p>
<ul>
<li>破坏性过滤：如果你想遍历一个集合，然后删除指定的元素，必须使用iterator，调用remove方法。或者使用Collection的removeIf方法。</li>
<li>转换：如果想要遍历集合或者数组替换部分元素的值，必须使用迭代器或者数组索引。</li>
<li>并行遍历要是用索引变量或者迭代器</li>
</ul>
<h2 id="59-了解和使用类库"><a href="#59-了解和使用类库" class="headerlink" title="59. 了解和使用类库"></a>59. 了解和使用类库</h2><p>使用标准类库，可以充分利用编写类库的专家知识；</p>
<p>不需要浪费时间来为一个和工作关系不大的问题编写特别的解决方法，应该关注在应用程序上而不是底层实现。</p>
<p>当你的需求比较特殊时，类库机制可能不会满足你的需求，这时候需要找第三方类库中看是否有合适的实现，比如Google的guava。否则的话就需要自己实现了。</p>
<h2 id="60-精确值避免使用float和double"><a href="#60-精确值避免使用float和double" class="headerlink" title="60. 精确值避免使用float和double"></a>60. 精确值避免使用float和double</h2><p>对于任何需要精确计算的结果，都不要使用float和double，使用BigDecimal来替换他，BigDecimal还有一个优点是，可以控制舍入的位数。</p>
<h2 id="61-基本类型优于封装类型"><a href="#61-基本类型优于封装类型" class="headerlink" title="61. 基本类型优于封装类型"></a>61. 基本类型优于封装类型</h2><p>基本类型和封装类型的三个不同点。</p>
<ol>
<li>基本类型比封装类型在时间和空间上更加节省</li>
<li>基本类型只有值，封装类型还有可能为null</li>
<li>封装类型除值的性质之外还有其他属性。虽然两个封装类型的值是一样的但是有可能是不同的对象。</li>
</ol>
<p>当面临选择的时候优先使用基本类型，因为基本类型简单且快速，当封装类型和基本类型混合计算的时候，会做拆箱的动作，这时有可能会抛出NullPointException。</p>
<h2 id="62-其他类型合适时避免使用String"><a href="#62-其他类型合适时避免使用String" class="headerlink" title="62. 其他类型合适时避免使用String"></a>62. 其他类型合适时避免使用String</h2><p>String是专门用来表示文本的，如果是数值类型不应该使用String表示。如果是是否选择问题应该转换成枚举或者boolean类型。</p>
<p>如果存在更加合适数据类型（或者可以编写一个）的时候，要避免习惯地使用字符串来表示对象。使用不当的话，String比其他类型会更加笨重、不灵活、慢、容易出错。很容易被错用成String的类型主要有基本类型、枚举类型和聚合类型。</p>
<h2 id="63-了解字符串拼接的性能"><a href="#63-了解字符串拼接的性能" class="headerlink" title="63. 了解字符串拼接的性能"></a>63. 了解字符串拼接的性能</h2><p>大规模字符串连接时，使用+操作符，需要的时间是N^2，因为字符串是不可变的，当两个字符串进行连接的时候，，需要将他们的内容都复制一下。</p>
<p>因此在字符串拼接的时候为了打到可接受的性能，可以使用StringBuilder代替String来保存构造过程中的声明。</p>
<h2 id="64-使用接口引用对象"><a href="#64-使用接口引用对象" class="headerlink" title="64. 使用接口引用对象"></a>64. 使用接口引用对象</h2><p>如果你养成了使用接口作为类型的习惯，程序就会变得非常灵活。无论是返回类型，参数类型，变量等都应该使用接口类型声明。</p>
<p>当没有合适的接口存在的时候，使用类而不是接口来引用对象，是非常合适的。比如String和BigInteger，通常返回是final的，也很少有对应的接口。</p>
<p>总的来讲，如果一个对象有合适的接口，使用接口来引用对象；如果没有合适的接口，就选择能够提供需要功能的最小的类。</p>
<h2 id="65-接口优于反射"><a href="#65-接口优于反射" class="headerlink" title="65. 接口优于反射"></a>65. 接口优于反射</h2><p>反射提供对人以类的编程式访问，给定一个Class对象，可以访问类的成员，域类型，方法等信息的能力。</p>
<p>Method.invoke()方法可以调用任何类的任何对象上的任何方法。反射机制允许一个类使用另一个类，即使在被编译之后不存在。</p>
<p>反射的缺点：</p>
<ul>
<li>丧失了编译时类型检查的好处。</li>
<li>执行反射访问所需要的代码比较长。</li>
<li>性能损失。</li>
</ul>
<p>对于复杂系统中特定的编程任务，反射是很有用的，但是它有很多缺点。如果编写的程序必须在编译时处理未知的类，则应该尽可能只使用反射实例化对象，并使用在编译时已知的接口或超类访问对象。</p>
<h2 id="66-谨慎的使用本地方法"><a href="#66-谨慎的使用本地方法" class="headerlink" title="66. 谨慎的使用本地方法"></a>66. 谨慎的使用本地方法</h2><p>Java本地接口（JNI）允许Java程序调用本地方法，这些方法是C或者C++编写的，主要用于提供特定平台的设施访问，对本地代码库的访问，对遗留数据库的访问。并且JNI注重性能。</p>
<p>在Java3以后，为了提高性能，很少使用本地方法，因为JVM已经做了性能优化，比如BigDecimal 1.3版本比1.1版本更快。</p>
<p>本地方法移植性较差，更难调试，如果使用不当回造成内存泄漏，并且代码可读性不是很好。</p>
<p>使用本地方法来访问底层资源或者本地库是可接受的但是需要完整彻底的测试。</p>
<h2 id="67-谨慎优化"><a href="#67-谨慎优化" class="headerlink" title="67. 谨慎优化"></a>67. 谨慎优化</h2><p>比起其他原因，很多出错的地方是源于优化。刚开始不要想着性能上的小小得失，优化失败的代价远比不做优化大。尤其是过早的优化，弊大于利，甚至过程中可能会出现无法修复的bug。</p>
<p>不能为了性能牺牲合理的架构，努力编写好的程序而不是快的程序。</p>
<p>在设计系统过程中就应该考虑到性能问题，因为当系统架构满足不了当前需求和性能时需要推到重来。</p>
<p>API设计对性能的影响是非常实际的。为了提升性能而改变API方法是一个非常糟糕的想法。</p>
<p>性能优化在测试前后对比可能并没有显著的提升，有时候还会变的更糟，因此将90%的时间花在10%的代码上市不划算的。</p>
<p>不同的硬件平台，版本，处理器上运行程序，性能是不一样的，有时候需要在环境和不同的实现上进行权衡。</p>
<p>找到性能提升的点，需要使用JVM分析器，分析代码出现的问题根源。</p>
<h2 id="68-遵守命名规范"><a href="#68-遵守命名规范" class="headerlink" title="68. 遵守命名规范"></a>68. 遵守命名规范</h2><p>包名和模块名应该是分层的，公司内部的包使用公司的域名开头，例如edu.cmu,com.google,org.eff。</p>
<p>类，接口，枚举，注释等遵循大驼峰命名规则。</p>
<p>方法名和字段名遵循小驼峰规则。</p>
<p>常量应该大写单词组成，多个单词之间通过下划线分隔。</p>
<p>类型参数名通常由单个字母组成，最常见的是T表示任意类型，E 表示集合的元素类型，K 和 V 表示 Map 的键和值类型，X 表示异常。函数的返回类型通常为 R。</p>
<p>方法名通常用动词或者动词短语命名，boolean返回的方法名通常是is，has开头，后面跟名词或者动词短语。</p>
<p>转换对象类型的方法通常是xxxToy，如toString()，toArray()；返回类型不同的视图，方法通常是以as开头。比如asList()，asType()。静态工厂的方法常见命名是from,of,valueOf,getInstance,newInstance等。</p>
<h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章 异常"></a>第九章 异常</h1><h2 id="69-仅在有异常条件下使用异常"><a href="#69-仅在有异常条件下使用异常" class="headerlink" title="69. 仅在有异常条件下使用异常"></a>69. 仅在有异常条件下使用异常</h2><p>因为异常是在特殊情况下设计的，所以JVM实现不会让他们和显示测试一样快。</p>
<p>将代码用try-cache包裹会抑制JVM可能执行的某些优化。</p>
<p>基于异常的循环会混淆代码并且降低代码的性能，而且不能保证他可以正常工作，如果循环中存在bug，使用异常进行流程控制会掩盖bug，从而增减调试过程的复杂性，假设循环体中的计算步骤调用了一个方法，该方法对一些不相关的数据执行越界访问，就会产生一个异常，导致线程立即终止，并带有完整的堆栈跟踪。但是如果用基于异常的循环，会误判为正常的循环终止条件。</p>
<p>使用标准的易于识别的用法，而不是声称可以提供更好性能的技术，只要不可靠就不应该被使用。</p>
<p>总之异常是为确有异常的情况设计的，不要将他们用于流程控制，也不要强制其他人这样做。</p>
<h2 id="70-对可恢复的情况使用检查异常，对编程错误使用运行时异常"><a href="#70-对可恢复的情况使用检查异常，对编程错误使用运行时异常" class="headerlink" title="70.对可恢复的情况使用检查异常，对编程错误使用运行时异常"></a>70.对可恢复的情况使用检查异常，对编程错误使用运行时异常</h2><h2 id="71-避免使用不必要的checked异常"><a href="#71-避免使用不必要的checked异常" class="headerlink" title="71.避免使用不必要的checked异常"></a>71.避免使用不必要的checked异常</h2><h2 id="72-复用标准异常"><a href="#72-复用标准异常" class="headerlink" title="72.复用标准异常"></a>72.复用标准异常</h2><h2 id="73-抛出能用抽象解释的异常"><a href="#73-抛出能用抽象解释的异常" class="headerlink" title="73.抛出能用抽象解释的异常"></a>73.抛出能用抽象解释的异常</h2><h2 id="74-为每个方法记录会抛出的所有异常"><a href="#74-为每个方法记录会抛出的所有异常" class="headerlink" title="74.为每个方法记录会抛出的所有异常"></a>74.为每个方法记录会抛出的所有异常</h2><h2 id="75-异常详细消息中应该包含捕获失败的信息"><a href="#75-异常详细消息中应该包含捕获失败的信息" class="headerlink" title="75.异常详细消息中应该包含捕获失败的信息"></a>75.异常详细消息中应该包含捕获失败的信息</h2><h2 id="76-尽力保证故障的原子性"><a href="#76-尽力保证故障的原子性" class="headerlink" title="76.尽力保证故障的原子性"></a>76.尽力保证故障的原子性</h2><h2 id="77-不能忽略异常"><a href="#77-不能忽略异常" class="headerlink" title="77.不能忽略异常"></a>77.不能忽略异常</h2><h1 id="第十章-并发"><a href="#第十章-并发" class="headerlink" title="第十章 并发"></a>第十章 并发</h1><h1 id="第十一章-序列化"><a href="#第十一章-序列化" class="headerlink" title="第十一章 序列化"></a>第十一章 序列化</h1><p>在线阅读地址：<a target="_blank" rel="noopener" href="https://jiapengcai.gitbooks.io/effective-java/content/chapter1/di-1-tiao-ff1a-kao-lv-yong-jing-tai-fang-fa-er-bu-shi-gou-zao-qi.html">Effective Java</a></p>

    </div>

    
    
    <div class="post-widgets">
    <div
      class="social-share"
      
        data-sites="weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google"
      
      
        data-wechat-qrcode-title="share.title"
      
      
        data-wechat-qrcode-helper="share.prompt"
      
    >
    </div>
  </div>
  <script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js"></script>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Author
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://itdatao.github.io/posts/21283aa4/" title="effective Java">http://itdatao.github.io/posts/21283aa4/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/posts/c24675b4/" rel="next" title="MySQL45讲笔记">
      MySQL45讲笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">第一章 创建和销毁对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">1. 考虑用静态代替构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BD%93%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BA%E8%80%85"><span class="nav-number">1.2.</span> <span class="nav-text">2. 当遇到多个构造器使用构建者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E8%80%85%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B"><span class="nav-number">1.3.</span> <span class="nav-text">3. 使用私有构造器或者枚举实现单例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">4. 使用私有构造器实现非实例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BC%98%E4%BA%8E%E7%A1%AC%E9%93%BE%E6%8E%A5%E8%B5%84%E6%BA%90"><span class="nav-number">1.5.</span> <span class="nav-text">5. 依赖注入优于硬链接资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.</span> <span class="nav-text">6. 避免创建不必要的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%B6%88%E9%99%A4%E8%BF%87%E6%97%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="nav-number">1.7.</span> <span class="nav-text">7. 消除过时的对象引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%B8%85%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.</span> <span class="nav-text">8. 避免使用终结方法和清理方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E4%BD%BF%E7%94%A8try-with-resources%E4%BB%A3%E6%9B%BFtry-finally"><span class="nav-number">1.9.</span> <span class="nav-text">9. 使用try-with-resources代替try-finally</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">第二章 所有对象都通用的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E8%A6%86%E7%9B%96equals%E6%96%B9%E6%B3%95%E6%97%B6%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-number">2.1.</span> <span class="nav-text">10. 覆盖equals方法时请遵守通用约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E6%80%BB%E8%A6%81%E9%87%8D%E5%86%99hashCode"><span class="nav-number">2.2.</span> <span class="nav-text">11. 重写equals方法时总要重写hashCode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%A7%8B%E7%BB%88%E8%A6%86%E7%9B%96toString"><span class="nav-number">2.3.</span> <span class="nav-text">12. 始终覆盖toString</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E8%B0%A8%E6%85%8E%E8%A6%86%E7%9B%96clone"><span class="nav-number">2.4.</span> <span class="nav-text">13. 谨慎覆盖clone</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E8%80%83%E8%99%91%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0comparable"><span class="nav-number">2.5.</span> <span class="nav-text">14. 考虑是否实现comparable</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">第三章 类和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E6%9C%80%E5%B0%8F%E5%8C%96%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">15. 最小化类和成员的访问性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%9C%A8%E5%85%AC%E6%9C%89%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%AC%E6%9C%89%E5%9F%9F"><span class="nav-number">3.2.</span> <span class="nav-text">16. 在公有类中使用访问方法而不是公有域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-number">3.3.</span> <span class="nav-text">17. 可变性最小化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">3.4.</span> <span class="nav-text">18. 组合优于继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E8%A6%81%E4%B9%88%E6%B6%89%E5%8F%8A%E7%BB%A7%E6%89%BF%E6%8F%90%E4%BE%9B%E6%96%87%E6%A1%A3%EF%BC%8C%E8%A6%81%E4%B9%88%E7%A6%81%E6%AD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">3.5.</span> <span class="nav-text">19. 要么涉及继承提供文档，要么禁止继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">3.6.</span> <span class="nav-text">20. 接口优于抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E4%B8%BA%E5%90%8E%E4%BB%A3%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.7.</span> <span class="nav-text">21. 为后代设计接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E6%8E%A5%E5%8F%A3%E5%8F%AA%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.8.</span> <span class="nav-text">22. 接口只用于定义类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E7%B1%BB%E5%B1%82%E6%AC%A1%E4%BC%98%E4%BA%8E%E6%A0%87%E7%AD%BE%E7%B1%BB"><span class="nav-number">3.9.</span> <span class="nav-text">23. 类层次优于标签类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB%E4%BC%98%E4%BA%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB"><span class="nav-number">3.10.</span> <span class="nav-text">24. 静态成员类优于非静态成员类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E9%99%90%E5%88%B6%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%BA%E5%8D%95%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%B1%BB"><span class="nav-number">3.11.</span> <span class="nav-text">25. 限制源文件为单个顶级类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">第四章 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">26. 不要使用原始类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E6%B6%88%E9%99%A4%E6%9C%AA%E6%A3%80%E6%9F%A5%E8%AD%A6%E5%91%8A"><span class="nav-number">4.2.</span> <span class="nav-text">27. 消除未检查警告</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E5%88%97%E8%A1%A8%E4%BC%98%E5%85%88%E4%BA%8E%E6%95%B0%E7%BB%84"><span class="nav-number">4.3.</span> <span class="nav-text">28. 列表优先于数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">29. 优先考虑使用泛型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">30. 优先考虑使用泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E4%BD%BF%E7%94%A8%E6%9C%89%E9%99%90%E5%88%B6%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9D%A5%E5%A2%9E%E5%8A%A0API%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-number">4.6.</span> <span class="nav-text">31. 使用有限制通配符来增加API灵活性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E5%90%88%E7%90%86%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-number">4.7.</span> <span class="nav-text">32. 合理结合泛型和变长参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E8%80%83%E8%99%91%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%82%E6%9E%84%E5%AE%B9%E5%99%A8"><span class="nav-number">4.8.</span> <span class="nav-text">33.考虑类型安全的异构容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">第五章 枚举和注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%9B%BF%E6%8D%A2%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.</span> <span class="nav-text">34.用枚举替换常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%9F%9F%E6%9D%A5%E6%9B%BF%E6%8D%A2%E5%BA%8F%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">35.使用实例域来替换序数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-%E4%BD%BF%E7%94%A8EnumSet%E6%9B%BF%E6%8D%A2%E4%BD%8D%E5%9F%9F"><span class="nav-number">5.3.</span> <span class="nav-text">36.使用EnumSet替换位域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E4%BD%BF%E7%94%A8EnumMap%E6%9B%BF%E6%8D%A2%E5%BA%8F%E6%95%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">5.4.</span> <span class="nav-text">37.使用EnumMap替换序数索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E6%A8%A1%E4%BB%BF%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">5.5.</span> <span class="nav-text">38.使用接口来模仿可扩展的枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-%E6%B3%A8%E8%A7%A3%E4%BC%98%E5%85%88%E4%BA%8E%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.6.</span> <span class="nav-text">39.注解优先于命名模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E5%9D%9A%E6%8C%81%E4%BD%BF%E7%94%A8Overide%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.7.</span> <span class="nav-text">40. 坚持使用Overide注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.8.</span> <span class="nav-text">41. 标记接口定义接口类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-Lambda%E5%92%8CStream"><span class="nav-number">6.</span> <span class="nav-text">第六章 Lambda和Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#42-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BC%98%E5%85%88%E4%BA%8E%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">42. lambda表达式优先于匿名类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%BC%98%E4%BA%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">43. 方法引用优于lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.3.</span> <span class="nav-text">44. 优先使用标准的函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E6%98%8E%E6%99%BA%E5%9C%B0%E4%BD%BF%E7%94%A8streams"><span class="nav-number">6.4.</span> <span class="nav-text">45. 明智地使用streams</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8Stream%E6%97%A0%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text">46. 优先使用Stream无副作用的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-Stream%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8Collection%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.6.</span> <span class="nav-text">47. Stream优先使用Collection作为返回类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8Stream%E5%B9%B6%E8%A1%8C"><span class="nav-number">6.7.</span> <span class="nav-text">48. 谨慎使用Stream并行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">第七章 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#49-%E6%A0%A1%E9%AA%8C%E5%8F%82%E6%95%B0%E6%9C%89%E6%95%88%E6%80%A7"><span class="nav-number">7.1.</span> <span class="nav-text">49. 校验参数有效性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-%E5%BF%85%E8%A6%81%E6%97%B6%E8%BF%9B%E8%A1%8C%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D"><span class="nav-number">7.2.</span> <span class="nav-text">50. 必要时进行保护性拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-%E8%B0%A8%E6%85%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="nav-number">7.3.</span> <span class="nav-text">51. 谨慎设计方法签名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-%E6%85%8E%E7%94%A8%E9%87%8D%E8%BD%BD"><span class="nav-number">7.4.</span> <span class="nav-text">52. 慎用重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-%E6%85%8E%E7%94%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">53. 慎用可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%9B%86%E5%90%88%E6%88%96%E8%80%85%E6%98%AF%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E6%98%AFnull"><span class="nav-number">7.6.</span> <span class="nav-text">54. 返回空集合或者是数组而不是null</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-%E8%B0%A8%E6%85%8E%E8%BF%94%E5%9B%9EOptionals"><span class="nav-number">7.7.</span> <span class="nav-text">55. 谨慎返回Optionals</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-%E4%B8%BA%E6%89%80%E6%9C%89%E5%AF%BC%E5%87%BA%E7%9A%84API%E5%85%83%E7%B4%A0%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="nav-number">7.8.</span> <span class="nav-text">56. 为所有导出的API元素编写文档注释</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.</span> <span class="nav-text">第八章 通用设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#57-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-number">8.1.</span> <span class="nav-text">57. 局部变量作用域最小化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-for-each%E4%BC%98%E4%BA%8E%E4%BC%A0%E7%BB%9Ffor%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.2.</span> <span class="nav-text">58. for-each优于传统for循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-%E4%BA%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%BA%93"><span class="nav-number">8.3.</span> <span class="nav-text">59. 了解和使用类库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60-%E7%B2%BE%E7%A1%AE%E5%80%BC%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8float%E5%92%8Cdouble"><span class="nav-number">8.4.</span> <span class="nav-text">60. 精确值避免使用float和double</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BC%98%E4%BA%8E%E5%B0%81%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.5.</span> <span class="nav-text">61. 基本类型优于封装类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%90%88%E9%80%82%E6%97%B6%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8String"><span class="nav-number">8.6.</span> <span class="nav-text">62. 其他类型合适时避免使用String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-%E4%BA%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">8.7.</span> <span class="nav-text">63. 了解字符串拼接的性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.8.</span> <span class="nav-text">64. 使用接口引用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E5%8F%8D%E5%B0%84"><span class="nav-number">8.9.</span> <span class="nav-text">65. 接口优于反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-%E8%B0%A8%E6%85%8E%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-number">8.10.</span> <span class="nav-text">66. 谨慎的使用本地方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-%E8%B0%A8%E6%85%8E%E4%BC%98%E5%8C%96"><span class="nav-number">8.11.</span> <span class="nav-text">67. 谨慎优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-%E9%81%B5%E5%AE%88%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">8.12.</span> <span class="nav-text">68. 遵守命名规范</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%BC%82%E5%B8%B8"><span class="nav-number">9.</span> <span class="nav-text">第九章 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#69-%E4%BB%85%E5%9C%A8%E6%9C%89%E5%BC%82%E5%B8%B8%E6%9D%A1%E4%BB%B6%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8"><span class="nav-number">9.1.</span> <span class="nav-text">69. 仅在有异常条件下使用异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70-%E5%AF%B9%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%AF%B9%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">9.2.</span> <span class="nav-text">70.对可恢复的情况使用检查异常，对编程错误使用运行时异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#71-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84checked%E5%BC%82%E5%B8%B8"><span class="nav-number">9.3.</span> <span class="nav-text">71.避免使用不必要的checked异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-%E5%A4%8D%E7%94%A8%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="nav-number">9.4.</span> <span class="nav-text">72.复用标准异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73-%E6%8A%9B%E5%87%BA%E8%83%BD%E7%94%A8%E6%8A%BD%E8%B1%A1%E8%A7%A3%E9%87%8A%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">9.5.</span> <span class="nav-text">73.抛出能用抽象解释的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#74-%E4%B8%BA%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95%E4%BC%9A%E6%8A%9B%E5%87%BA%E7%9A%84%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="nav-number">9.6.</span> <span class="nav-text">74.为每个方法记录会抛出的所有异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75-%E5%BC%82%E5%B8%B8%E8%AF%A6%E7%BB%86%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E6%8D%95%E8%8E%B7%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">9.7.</span> <span class="nav-text">75.异常详细消息中应该包含捕获失败的信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#76-%E5%B0%BD%E5%8A%9B%E4%BF%9D%E8%AF%81%E6%95%85%E9%9A%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">9.8.</span> <span class="nav-text">76.尽力保证故障的原子性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#77-%E4%B8%8D%E8%83%BD%E5%BF%BD%E7%95%A5%E5%BC%82%E5%B8%B8"><span class="nav-number">9.9.</span> <span class="nav-text">77.不能忽略异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="nav-number">10.</span> <span class="nav-text">第十章 并发</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">11.</span> <span class="nav-text">第十一章 序列化</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="https://s2.loli.net/2023/02/26/PVfcsSojHARqp1y.jpg">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/itdatao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;itdatao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://huitao233@gmail.com/" title="E-Mail → https:&#x2F;&#x2F;huitao233@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">60k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">54 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '68ae00996366cbfe27b7',
      clientSecret: '0a2d65cea9a9024872be4217ddf0af3d4d017ba0',
      repo        : 'blog-comments',
      owner       : 'itdatao',
      admin       : ['itdatao'],
      id          : 'e72fe371e5e0f4a2a9e52d571e669f59',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
