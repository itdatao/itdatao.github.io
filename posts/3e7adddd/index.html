<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"itdatao.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"border_radius":8,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MQ（message Queue）：翻译为消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入…">
<meta property="og:type" content="article">
<meta property="og:title" content="rocketmq">
<meta property="og:url" content="http://itdatao.github.io/posts/3e7adddd/index.html">
<meta property="og:site_name" content="流沙的个人空间">
<meta property="og:description" content="MQ（message Queue）：翻译为消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入…">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image-20211117153318353.png">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image-20211117154638428.png">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image-20211117171323228.png">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image-20211117171437947.png">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image-20211117173342358.png">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image-20211113205859373.png">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image.png">
<meta property="og:image" content="http://itdatao.github.io/posts/3e7adddd/image.png">
<meta property="article:published_time" content="2023-03-02T09:13:08.000Z">
<meta property="article:modified_time" content="2023-03-19T08:51:43.113Z">
<meta property="article:author" content="H2T">
<meta property="article:tag" content="rocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://itdatao.github.io/posts/3e7adddd/image-20211117153318353.png">

<link rel="canonical" href="http://itdatao.github.io/posts/3e7adddd/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css">
  <title>rocketmq | 流沙的个人空间</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">流沙的个人空间</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">this is an interesting blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://itdatao.github.io/posts/3e7adddd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s2.loli.net/2023/02/26/PVfcsSojHARqp1y.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="流沙的个人空间">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rocketmq
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-02 17:13:08" itemprop="dateCreated datePublished" datetime="2023-03-02T17:13:08+08:00">2023-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-19 16:51:43" itemprop="dateModified" datetime="2023-03-19T16:51:43+08:00">2023-03-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        
<p>MQ（message Queue）：翻译为消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入…</p>


<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是MQ？"><a href="#什么是MQ？" class="headerlink" title="什么是MQ？"></a>什么是MQ？</h3><p>MQ（message Queue）：翻译为消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间的解耦。别名为消息中间件。通过利用高效可靠的消息传递机制进行平台无关的数据交流，并给予数据通信来进行分布式系统的集成。</p>
<h3 id="MQ有哪些？"><a href="#MQ有哪些？" class="headerlink" title="MQ有哪些？"></a>MQ有哪些？</h3><p>老牌的ActiveMQ、RabbitMQ、当今热门的Kafka,阿里巴巴自主开发的RocketMQ等。</p>
<h3 id="不同的MQ的特点"><a href="#不同的MQ的特点" class="headerlink" title="不同的MQ的特点"></a>不同的MQ的特点</h3><p><strong>ActiveMQ</strong>是由Apache出品的一款开源消息中间件，旨在为应用程序提供高效、可扩展、稳定、安全的企业级消息通信。ActiveMQ实现了JMS 1.1 并提供了很多附加的特性，比如JMX管理、主从管理、消息组通信、消息优先级、延迟接收消息、虚拟接收者、消息持久化、消息队列监控等。主要特性如下：</p>
<ul>
<li>支持Java、C、C++、C#、Ruby、Perl、Python、PHP等多种语言的客户端和协议，如OpenWire、STOMP、AMQP、MQTT协议。</li>
<li>提供了像消息组通信、消息优先级、延迟接收消息、虚拟接收者、消息持久化之类的高级特性。</li>
<li>完全支持JMS 1.1 和 J2EE 1.4 规范 (包括持久化、分布式事务消息、事务)</li>
<li>支持Spring框架，ActiveMQ 可以通过Spring 的配置文件方式很容易嵌入Spring应用中。</li>
<li>通过了常见的J2EE服务器测试，比如TomEE、Geronimo、JBoss、GlassFish、WebLogic。</li>
<li>连接方式多样化，ActiveMQ 提供了多种连接方式，例如 in-VM、TCP、SSL、NIO、UDP、多播、JGroups、JXTA。</li>
<li>支持通过使用JDBC 和 Journal 实现消息的快速持久化。</li>
<li>为高性能集群、客户端-服务器、点对点通信等场景而设计。</li>
<li>提供了技术和语言中立的REST API 接口。</li>
<li>支持以AJAX 方式调用 ActiveMQ。</li>
<li>ActiveMQ 可以轻松地与CXF、Axis 等 WebService 技术整合，以提供可靠的消息传递。</li>
<li>可以作为内存中的JMS 提供者，非常适合 JMS 单元测试。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="限流削峰"><a href="#限流削峰" class="headerlink" title="限流削峰"></a>限流削峰</h4><p>MQ可以将系统中超量的请求暂时存在其中，以便于后期可以慢慢处理，从而避免了请求的丢失或者系统被大流量打垮。</p>
<h4 id="异步解耦"><a href="#异步解耦" class="headerlink" title="异步解耦"></a>异步解耦</h4><p>上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量和并发度，且系统耦合度太高。异步调用则会解决这个问题。</p>
<h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><p>通过MQ可以收集业务日志，用户行为等数据。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><p>RocketMQ由Producer、Consumer、Broker三部分组成，Produce负责生产消息，Consumer负责消费消息，Broker负责存储消息，Broker在实际部署过程中对应一台服务器，每个Broker可以存储多个Topic的消息，每个Topic消息可以分片存储于不同的Broker。Message Queue用于存储消息的物理地址，每个Topic中的消息地址存储于多个Message Queue中。Consumer Group由多个Consumer实例构成。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>泛指所传输信息的物理载体，生产和消费的最小数据单位，每条消息必须属于一个主题。RocketMQ中每个消息都拥有唯一的MessageID，并且可以携带具有业务标识的key，系统提供了通过Message ID和Key查询消息的功能。</p>
<h3 id="Topic主题"><a href="#Topic主题" class="headerlink" title="Topic主题"></a>Topic主题</h3><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>消息的标签，用于区分同一主题下的不同类型的消息，来自同一业务单元的消息，可以根据不同业务目的在同一个主题下设置不同的标签。标签能够有效保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>一个消息生产者会把业务应用系统里产生的消息发送到broker服务器，RocketMQ提供多种发送方式。同步发送，异步发送，顺序发送，单向发送。同步和异步方式均需要broker返回确认消息，单向发送不需要。</p>
<p>消息生产者支持分布式集群方式部署。通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息，并将消息提供给应用程序。从用户的角度是提供了两种方式，拉取式消费和推送式消费。支持分布式集群方式部署，支持push推和pull拉两种方式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求.</p>
<h3 id="Broker-Server"><a href="#Broker-Server" class="headerlink" title="Broker Server"></a>Broker Server</h3><p>代理服务器，负责存储转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储，同时为消费者的拉取请求做准备。代理服务器页存储消息相关的元数据信息（消息进度偏移量，主题，队列消息等）。</p>
<h3 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h3><p>名称服务充当路由信息的提供者。生产者或消费者能够通过名字服务查找各个主题相应的Broker IP列表。多个NameServer实例组成的集群，但是相互独立，没有信息交换。类似于Dubbo中的zookeeper,支持Broker的动态注册与发现,主要包括两个功能,一个是Broker管理，另一个是路由信息管理.NameServer接收Broker集群的注册信息并且保存下来作为路由信息的基本数据.然后提供心跳检测机制,检查Broker是否还能存活;路由信息管理,每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息然后Producer和Consumer提供NameServer就能知道整个Broker的路由信息,从而进行投递和消费.NameServer通常也是集群部署,各个实例之间不进行通信.Broker是向每台NameServer注册自己的路由信息,所以每个NameServer实例上面都保存一份完整的路由信息.当某个NameServer因为某种原因下线了,Broker仍然可以向其他NameServer同步路由信息,Producer和Consumer仍然可以动态感知Broker的路由信息。</p>
<h3 id="拉取式消费"><a href="#拉取式消费" class="headerlink" title="拉取式消费"></a>拉取式消费</h3><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉取消息，主动权由应用控制，一旦获取了批量信息，应用就会启动消费过程。</p>
<h3 id="推动式消费"><a href="#推动式消费" class="headerlink" title="推动式消费"></a>推动式消费</h3><p>Consumer的另一种消费方式，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<h3 id="生产者组"><a href="#生产者组" class="headerlink" title="生产者组"></a>生产者组</h3><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致，如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会练习同一生产者实例以提交或者回溯消息。</p>
<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>同类Consumer的集合。要求这类消费者消费逻辑一致，消费的是同一类消息。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易，要注意的是，消费者组的消费者实例必须订阅完全相同的Topic，RocketMQ支持两种消息模式：集群消费和广播消费。</p>
<h3 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h3><p>相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h3 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h3><p>相同Consumer Group的每个Consumer实例都全量接收消息。</p>
<h3 id="普通顺序消息"><a href="#普通顺序消息" class="headerlink" title="普通顺序消息"></a>普通顺序消息</h3><p>在该模式下，消费者通过同一个消息队列收到的消息是有顺序的，不同的消息队列收到的消息则可能是无顺序的。</p>
<h3 id="严格顺序消息"><a href="#严格顺序消息" class="headerlink" title="严格顺序消息"></a>严格顺序消息</h3><p>消费者收到的消息都是严格有序的。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="消息的订阅与发布"><a href="#消息的订阅与发布" class="headerlink" title="消息的订阅与发布"></a>消息的订阅与发布</h3><p>消息的发布是指某个生产者向某个topic发送消息，消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p>
<h3 id="消息的有序"><a href="#消息的有序" class="headerlink" title="消息的有序"></a>消息的有序</h3><p>消息的有序是指一类消息消费时，能按照发送的顺序来消费，例如：一个订单残生了三个消息分别是创建订单，订单付款，订单完成，消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格保证消息的有序。</p>
<p>顺序消息分为全局顺序消息和分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一个组消息被顺序消费就可以。</p>
<p>全局顺序的适用场景：对于指定的topic，所有消息按照严格的FIFO发布和消费，适用于性能要求不高，所有的消息严格按照FIFO原则进行消息发布和消费的场景。</p>
<p>分区顺序的适用场景：针对的是同一个Topic中根据sharding key进行区块分区。同一个分区内的消息按照严格的FIFO顺序进行发布和消费。Sharding key是用来区分不同分区的关键字段，和不同的key是不同的概念，适用于性能要求很高，在同一个区块中严格按照FIFO原则进行消息发布和消费的场景。</p>
<h3 id="消息的过滤"><a href="#消息的过滤" class="headerlink" title="消息的过滤"></a>消息的过滤</h3><p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤，消息过滤目前是Broker端实现的，有点事减少对于Consumer无用的网络传输，缺点是增加了Broker的负担，而且实现相对复杂。</p>
<h3 id="对消息可靠性的影响因素"><a href="#对消息可靠性的影响因素" class="headerlink" title="对消息可靠性的影响因素"></a>对消息可靠性的影响因素</h3><ol>
<li>Broker非正常关闭</li>
<li>Broker异常Crash</li>
<li>操作系统Crash</li>
<li>机器掉电但是能立即恢复供电情况</li>
<li>机器无法开机（可能是CPU，主板，内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>1、2、3、4四种情况属于硬件资源可以例子恢复的情况，在这几种情况下可以保证消息不丢失或者丢失少量消息。5，6情况属于单点故障且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可以保证99%的消息不丢但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场景，例如对金额的实时计算。</p>
<h3 id="至少一次（At-least-once）"><a href="#至少一次（At-least-once）" class="headerlink" title="至少一次（At least once）"></a>至少一次（At least once）</h3><p>至少一次是指每个消息至少投递一次，Consumer先拉取到本地，消费完之后才会返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持该特性。</p>
<h3 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h3><p>回溯消费是指Consumer已经消费成功，但由于业务需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留，并且重新消费一般是按照时间维度，例如Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度回退消费进度，回退的时间维度精确到毫秒。</p>
<h3 id="事务消息和定时消息"><a href="#事务消息和定时消息" class="headerlink" title="事务消息和定时消息"></a>事务消息和定时消息</h3><p>事务消息是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败，RocketMQ的事务消息提供X/Open XA的分布式功能，通过事务消息能达到分布式事务的最终一致性。</p>
<p>定时消息（延迟队列）是指消息发送到Broker后，不会立即被消费，等待特定时间投递给真正的topic，broker由配置项messageDelayLevel，默认是18个等级，“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，这个延后时间等级可以自定义，需要注意的是messageDelayLevel是Broker的属性，不属于某个topic，发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。</p>
<ul>
<li>当level==0,消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1秒</li>
<li>当level&gt;maxLevel，则level==maxLevel</li>
</ul>
<p>定时消费会暂存在名为SCHEDULE_TOPIC_XXX的topic中，并根据delayTimeLevel存入特定的queue，queueId=delayTimeLevel-1，即一个queue只存在相同的延迟消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度消费SCHEDULE_TOPIC_XXXX,将消息写入真实的topic。需要注意的是，定时消息还在第一次写入和调度写入时都会计数，因此发送数量，tps都会变高。</p>
<h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>Consumer消费失败之后，要提供重试机制，让消息再消费一次。消息消费失败的原因</p>
<ul>
<li>由于消息本身的原因，例如序列化失败，消息数据本身因为业务无法处理等，这种错误通常要跳过这个消息，再消费其他消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，过10s后再重试。</li>
<li>由于依赖的下有服务不可用也会造成消费失败，这种情况即使跳过这条消息，其他消息也会报错，应该建议应用sleep30s，再消费下一条消息，这样可以减轻Broker重试消费的压力。</li>
</ul>
<h3 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h3><p>消息重投保证消息尽可能发送成功，不丢失但可能会造成重复消费，消息重复在RocketMQ是无法避免的问题，消息重复在一般情况下不会发生当出现消息量大，网络抖动，消息重复就会是大概率事件，另外生产者主动重发，consumer负载变化也会导致重复消息。</p>
<p>消息重试策略</p>
<ul>
<li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed+ 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li>
<li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li>
<li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p>
<p>生产者流量控制：</p>
<ol>
<li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认是1000ms，返回流控。</li>
<li>如果开启transientStorePollEnable==true，且broker为异步刷盘的主机，transientStorePool中资源不足，拒绝当前send请求，返回流控。</li>
<li>Broker每个10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsLnSendQueue，默认200ms，拒绝当前send请求，返回流控。</li>
<li>broker通过拒绝send请求方式实现流量控制</li>
</ol>
<p>生产者流控不会尝试消息重投。</p>
<p>消费者流量控制：</p>
<ul>
<li>消费者本地缓存消息数超过pillThresholdForQueue时，默认1000。</li>
<li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB</li>
<li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认是2000。</li>
</ul>
<p>消费者流量控制的结果是拉取频率。</p>
<h3 id="什么是死信队列"><a href="#什么是死信队列" class="headerlink" title="什么是死信队列"></a>什么是死信队列</h3><p>死信队列是处理无法被正常消费的消息。当一条消息初次消费失败后，消息队列会对进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确的消费该消息，此时，消息队列不会立刻丢弃这条消息，而是将他存储在死信队列中。RocketMQ可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序是指可以按照消息的发送顺序来消费。RocketMQ分给分区有序和全局有序。</p>
<p>顺序消费的原理：在默认情况下消息发送会采用轮询的方式将消息发送到不同的queue（分区队列）；而消费消息的时候从多个queue中拉取消息，这种情况发送和消费是不能够保证有序，但是如果发送的消息只发送到同一个queue，消费的时候只从这个queue中取消息，就能保证顺序，当发送和消费参与的queue只有一个，则是全局有序；如果有多个queue参与，则为分区有序，也就是相对每个queue，消息都是有序的。</p>
<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>使用场景：比如提交一个订单之后就可以发送一个延时消息，1小时候后检查这个订单状态，如果还是未支付就释放库存。</p>
<p>RocketMQ并不支持任意时间的延时，需要设置几个固定的延时等级，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>消息发送的时间和设置的等级与重试次数有关。</p>
<p>想要批量发送消息的条件是这些消息应该有相同的topic，相同的waitStoreMsgOK，并且不能是延时消息，此外这批消息的总大小不应该超过4MB。</p>
<p>根据标签过滤消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br><span class="line"><span class="comment">// 消费者将接收TAGA,TAGB,TAGC的消息，但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用，在这种情况下，可以使用SQL表达式筛选消息。</span></span><br></pre></td></tr></table></figure>

<p>只有使用push模式的消费者才能用使用SQL92标准的sql语句</p>
<p> public void subscribe(final String topic, final MessageSelector messageSelector)</p>
<p>生产者可以通过putUserProperty()方法来设置消息的属性。</p>
<h2 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h2><p>整体架构采用的是混合型存储结构，单个Broker实例下的所有队列共用一个commitlog。也就是多个topic的内容都存储到一个CommitLog中，只要Broker端采用同步或者异步的方式将消息保存到CommitLog中就不会丢失消息。服务端支持长轮询模式，如果一个消息拉去请求没有拉到消息，Broker允许等待30s，只要在这段时间内有新消息到达，将直接返回给消费端。</p>
<ol>
<li>CommitLog：消息主题以及元数据的存储主题，存储生产者写入的消息主题内容，消息内容不是定长的，单个文件大小默认是1G，文件名长度20位，左边补充0，剩余是起始偏移量。消<strong>息是顺序写入到日志文件的</strong>，当文件写满之后再写下一个文件。顺序写入磁盘是随机写效率的6000倍。</li>
<li>ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，主要用来存储消息在commitlog的索引。由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件根据topic检索是非常低效的，ConsumeQueue作为消费消息的索引，保存指定topic下的队列消息在commitlog中的其实物理偏移量offset，消息大小size,tag的hashcode值，consumequeue文件可以看成是基于topic的commitlog索引文件，所以具体存储路径是$HOME/store/consumequeue/{topic}/{queueId}/{fileName}，consumequeue文件采取定长设计，每个条目一共20个字节，单个文件由30w个条目组成，可以像数组一样随机访问每个条目，每个ConsumeQueue文件大小大约5.72M。</li>
<li>IndexFile：索引文件提供一种可以通过key或者时间区间来查询消息的方法。Index文件的存储位置是$HOME \store\index${fileName}，文件名是以创建时间戳命名的，固定单个IndexFile文件大小约400M，一个IndexFile可以保存2000W个索引，索引文件底层实现是hash索引。</li>
</ol>
<p><strong>页缓存：</strong>是操作系统对文件的缓存，用于加速对文件的读写，一般来讲，顺序读写的速度几乎接近于内存的读写速度，主要原因就是使用了PageCache机制对读写访问操作进行了优化，将一部分内存用作页缓存。写的时候先写入到PageCache，随后通过异步的方式同步到物理磁盘上，对于读取操作，如果未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对相邻的数据预读取。</p>
<p><strong>零拷贝</strong>：RocketMQ利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种mmap的方式减少了一次从操作系统内核缓冲区到用户应用地址空间的缓冲区的拷贝），从而极大底稿了文件的读写效率。</p>
<p>消息刷盘</p>
<ul>
<li>同步刷盘：只有消息真正持久化到磁盘后，Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来讲是一种不错的保障，但是性能上会有较大影响，但是这种相比于异步刷盘更安全，因此常用于金融业务。</li>
<li>异步刷盘：只要消息写入到PageCache，即可将成功的ACK返回给Producer端，消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提供性能和吞吐量。</li>
</ul>
<h2 id="消息的高可用性"><a href="#消息的高可用性" class="headerlink" title="消息的高可用性"></a>消息的高可用性</h2><p>RocketMQ分布式集群是通过MASTER和Slave的配合达到高可用性的。</p>
<p>Master和Slave的区别：在Broker的配置文件中，参数brokerId的值为0表明这个Broker是Master，大于0表名这个是Slave。brokerRole参数也会说明这个Broker是Master还是Slave。</p>
<p>Producer只能和Master角色的Broker连接写入消息；Consumer两者都可以连接读取消息。</p>
<h3 id="消费端高可用"><a href="#消费端高可用" class="headerlink" title="消费端高可用"></a>消费端高可用</h3><p>当Master繁忙或者不可用的时候，Consumer可以自动切换到Slave读，有了自动切换Consumer，可以保证消费端的高可用。</p>
<h3 id="发送端高可用"><a href="#发送端高可用" class="headerlink" title="发送端高可用"></a>发送端高可用</h3><p>producer发送消息时，将Topic的多个Message Queue创建在多个Broker组上（Broker名字相同，Id不同），当一个Broker组的Master不可用之后，Producer仍然可以发送消息。RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足，需要手动停止Slave，更改配置文件，用新的配置文件启动Broker。</p>
<h2 id="消息的主从复制"><a href="#消息的主从复制" class="headerlink" title="消息的主从复制"></a>消息的主从复制</h2><p>同步复制：Master和Slave均要写成功之后才会反馈给客户端。</p>
<p>如果Master出现故障，Slave上全部的备份数据，容易恢复，但是同步复制会增大数据写入延迟，降低系统的吞吐量。</p>
<p>异步复制：只要Master写成功就会反馈给客户端写成功状态。异步复制具有较低的延迟和高吞吐量，但是当Master出现故障，这时Slave上的数据有可能是不完整的，因此会出现消息丢失，不可靠。</p>
<p>配置文件：brokerRole=ASYNC_MASTER/SYNC_MASTER/SLAVE；异步，同步都是在主Broker配置的，如果是从Broker配置成Slave。</p>
<p>通常使用时，会将刷盘方式配置成异步刷盘，主从复制配置成同步复制。</p>
<h2 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h2><p>rocketMQ的基本通讯过程如下</p>
<ol>
<li>Broker启动之后需要完成一次将自己注册到NameServer的操作；随后每隔30s时间向NameServer上报Topic信息。</li>
<li>消息生产者作为客户端发送消息的时候，需要根据消息的topic从本地缓存的TopicPublishInfoTable中获取路由信息，如果TopicpushinfoTable中没有信息就会从NameServer上重新拉起一次消息并更新TopicPublishInfoTable。</li>
<li>producer从路由信息中选择一个队列进行消息发送；Broker作为消息的接受者接收消息并落盘存储。</li>
<li>消息消费者获取路由信息并完成客户端的负载均衡后，选择其中的一个或者几个消息队列来拉取消息并进行消费。</li>
</ol>
<p>通信类的结构</p>
<p><img src="/posts/3e7adddd/image-20211117153318353.png" alt="img"></p>
<p><strong>协议与编码</strong></p>
<p>为了高效的传输信息和读取收到的消息，就需要对消息进行编解码。RemotingCommand这个类在消息传输过程中对所有数据内容进行了封装，不但包含了所有的数据结构还有编解码操作。</p>
<p>消息头：</p>
<table>
<thead>
<tr>
<th><strong>Header字段</strong></th>
<th><strong>类型</strong></th>
<th><strong>Request说明</strong></th>
<th><strong>Response说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的业务处理</td>
<td>应答响应码。0表示成功，非0则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p>消息体</p>
<p><img src="/posts/3e7adddd/image-20211117154638428.png" alt="img"></p>
<p>消息总长度：自个字节，占用一个int类型</p>
<p>序列化类型和消息头长度：同样占用一个int类型，第一个字节表示序列化类型，后面三个字节表示消息头长度。</p>
<p>消息头数据：经过序列化后的消息头数据；</p>
<p>消息主体数据：消息主体的二进制字节数据内容。</p>
<p><strong>通信方式</strong>：同步，异步，单向三种，其中单向一般用在发送心跳包不关注response。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>RocketMQ的负载均衡都在Client端完成。分为Producer发送消息的负载均衡和Consumer端订阅消息的负载均衡。</p>
<h3 id="Producer的负载均衡"><a href="#Producer的负载均衡" class="headerlink" title="Producer的负载均衡"></a>Producer的负载均衡</h3><p>生产者发送消息的时候，会根据topic找到指定的TopicPublishInfo，在获取TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue方法会从TopicPublishInfo中选一个队列发消息。具体的容错策略都是在MQFaultStrategy这个类中定义。MQFaultStrategy中有一个sendLatencyFaultEnable 的私有属性，默认是false，当这个开关打开后会在随机递增基础上过滤掉不可靠的broker代理。是对之前失败的，按一定时间做回退。latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p>
<h3 id="Consumer的负载均衡"><a href="#Consumer的负载均衡" class="headerlink" title="Consumer的负载均衡"></a>Consumer的负载均衡</h3><p>在RocketMQ中，Consumer端的两种消费模式其实都是基于pull拉模式获取消息的，Push模式只是对pull模式的一种封装，其本质上是为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又马不停蹄的继续向服务器再次尝试拉取消息。如果未拉取消息，则延迟一下又会继续拉取。在两种基于拉取模式的消费模式中，都需要Consumer端在知道从Broker端的哪一个消息队列中获取消息，即是Broker端中多个MessageQueue分配到同一个消费组中对应给哪些Consumer消费。</p>
<p>1、consumer端的心跳包发送</p>
<p>在consumer启动之后，他就会通过定时任务不断的向RocketMQ集群中的所有broker实例发送心跳包。broker收到心跳消息之后会在本地维护一个consumerTable，同时将封装好的客户端网络通道信息保存到本地channelInfoTable中为以后做consumer端的负载均衡提供可以依据的数据信息。</p>
<p>2、consumer端实现负载均衡的核心类是RebalanceImpl。</p>
<p>consumer实例启动流程中会启动MQClientInstance实例，会完成负载均衡服务线程RebalanceService的启动，RebalanceService线程的run方法最终会调用RebalanceImpl的rebalanceByTopic方法，这个方法是负载均衡的核心实现。会根据消费者通信类型（广播和集群模式）的不同做不同的处理。</p>
<p>集群模式下的主要处理流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rebalanceByTopic</span><span class="params">(String topic, <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">    Set mqSet;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">this</span>.messageModel) &#123;</span><br><span class="line">            <span class="comment">//广播模式</span></span><br><span class="line">    <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">        mqSet = (Set)<span class="built_in">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (mqSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="built_in">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                <span class="built_in">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">                log.info(<span class="string">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.consumerGroup, topic, mqSet, mqSet&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, <span class="built_in">this</span>.consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CLUSTERING:<span class="comment">//集群模式</span></span><br><span class="line">            <span class="comment">//从本地缓存变量topicSubscribeInfoTable获取该topic主题下的消费队列集合</span></span><br><span class="line">        mqSet = (Set)<span class="built_in">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">            <span class="comment">//根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取该消费组下消费者Id列表的RPC通信请求</span></span><br><span class="line">        List&lt;String&gt; cidAll = <span class="built_in">this</span>.mQClientFactory.findConsumerIdList(topic, <span class="built_in">this</span>.consumerGroup);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == mqSet &amp;&amp; !topic.startsWith(<span class="string">&quot;%RETRY%&quot;</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, <span class="built_in">this</span>.consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == cidAll) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed&quot;</span>, <span class="built_in">this</span>.consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mqSet != <span class="literal">null</span> &amp;&amp; cidAll != <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            mqAll.addAll(mqSet);</span><br><span class="line">            <span class="comment">//先对消息消费队列，消费者ID进行排序</span></span><br><span class="line">            Collections.sort(mqAll);</span><br><span class="line">            Collections.sort(cidAll);</span><br><span class="line">            <span class="type">AllocateMessageQueueStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="built_in">this</span>.allocateMessageQueueStrategy;</span><br><span class="line">            <span class="type">List</span> <span class="variable">allocateResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//计算待拉取的消息队列</span></span><br><span class="line">                allocateResult = strategy.allocate(<span class="built_in">this</span>.consumerGroup, <span class="built_in">this</span>.mQClientFactory.getClientId(), mqAll, cidAll);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(), var10);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            <span class="keyword">if</span> (allocateResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                allocateResultSet.addAll(allocateResult);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="built_in">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;strategy.getName(), <span class="built_in">this</span>.consumerGroup, topic, <span class="built_in">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(), allocateResultSet.size(), allocateResultSet&#125;);</span><br><span class="line">                <span class="built_in">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/3e7adddd/image-20211117171323228.png" alt="img"></p>
<ul>
<li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</li>
<li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</li>
</ul>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>rocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p>
<p><img src="/posts/3e7adddd/image-20211117171437947.png" alt="img"></p>
<h3 id="事务消息的发送与提交流程。"><a href="#事务消息的发送与提交流程。" class="headerlink" title="事务消息的发送与提交流程。"></a>事务消息的发送与提交流程。</h3><ol>
<li>发送half消息。</li>
<li>服务端响应消息写入结果。</li>
<li>根据发送结果执行本地事务，如果写入失败，该half消息对业务不可见</li>
<li>根据本地事务状态执行commit或者rollback。commit会生成消息索引对业务可见。</li>
</ol>
<p>补偿机制主要是解决当commit或者rollback执行失败之后的挽救措施。</p>
<ol>
<li>对没有commit或者rollback的消息，服务端会进行回查。</li>
<li>生产者检查本地事务消息的状态。</li>
<li>根据状态重新commit或者rollback。</li>
</ol>
<p>RocketMQ事务消息不可见的实现策略：写入的事务消息，会对topic和queue等属性进行替换，正因为消息主题被替换了，所以消息不会转发到原先主题的消费队列中，所以消费者无法感知这个消息的存在。</p>
<h3 id="Op消息的引入"><a href="#Op消息的引入" class="headerlink" title="Op消息的引入"></a>Op消息的引入</h3><p>如果第二阶段是进行Rollback操作，就需要撤销第一阶段的消息，但是不是真正意义上的撤销，因为是顺序写入文件的，但是区别是这条消息没有确定状态，需要一个操作表示这个状态，因此引入了Op消息的概念。Op消息是用来表示事务消息已经确定的状态（要么是Commit要么是Rollback）。如果一条消息没有对应的Op消息，就代表该事务消息还无法确定。</p>
<h3 id="Op消息的存储和对应关系"><a href="#Op消息的存储和对应关系" class="headerlink" title="Op消息的存储和对应关系"></a>Op消息的存储和对应关系</h3><p>rocketMQ将Op消息写入到一个内部的Topic中，这个topic不会被用户消费。Op消息的内容是对应的Half消息的存储的Offset，这样通过Op消息能定位到Half消息，进行后续的操作。</p>
<p><img src="/posts/3e7adddd/image-20211117173342358.png" alt="img"></p>
<h3 id="Half消息的索引构建"><a href="#Half消息的索引构建" class="headerlink" title="Half消息的索引构建"></a>Half消息的索引构建</h3><p>事务消息的第二次提交其实是利用第一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入的流程。</p>
<h3 id="2PC失败时消息该如何处理"><a href="#2PC失败时消息该如何处理" class="headerlink" title="2PC失败时消息该如何处理"></a>2PC失败时消息该如何处理</h3><p>例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。RocketMQ采用了一种补偿机制，称为“<strong>回查</strong>”。Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推CheckPoint（记录那些事务消息的状态是确定的）。</p>
<p>值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查<strong>15</strong>次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</p>
<h2 id="消息的查询"><a href="#消息的查询" class="headerlink" title="消息的查询"></a>消息的查询</h2><p>RocketMQ支持两种查询方式，一种是按照messageID查询，另一种是按照message Key查询。</p>
<ol>
<li>MessageID的长度一共有16个字节，其中包含了消息存储的主机地址，消息CommitLog offset。按照MessageId查询消息“在RocketMQ中具体的做法是：Client端从MessageId解析出Broker的底子好和CommitLog的偏移量之后封装成一个RPC请求通过通信层发送。”</li>
<li>按照Message Key查询消息。这种是基于IndexFile索引文件来实现的。索引文件的结构类似于HashMap。40 Byte 的Header用于保存一些总的统计信息，4<em>500W的 Slot Table并不保存真正的索引数据，而是保存每个槽位对应的单向链表的头。20</em>2000W 是真正的索引数据，即一个 Index File 可以保存 2000W个索引。“按照Message Key查询消息”的方式，RocketMQ的具体做法是，主要通过Broker端的QueryMessageProcessor业务处理器来查询，读取消息的过程就是用topic和key找到IndexFile索引文件中的一条记录，根据其中的commitLog offset从CommitLog文件中读取消息的实体内容。</li>
</ol>
<p><img src="/posts/3e7adddd/image-20211113205859373.png" alt="img"></p>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="MQ的作用？"><a href="#MQ的作用？" class="headerlink" title="MQ的作用？"></a>MQ的作用？</h2><p>降低系统耦合，异步处理提升响应时间，请求到达峰值后，可以保持固定消费速率用于流量削峰。</p>
<h2 id="RocketMQ的角色组成以及各个角色的作用？"><a href="#RocketMQ的角色组成以及各个角色的作用？" class="headerlink" title="RocketMQ的角色组成以及各个角色的作用？"></a>RocketMQ的角色组成以及各个角色的作用？</h2><ol>
<li>Nameserver：无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。</li>
<li>Producer：消息生产者，负责发消息到Broker。</li>
<li>Broker：就是MQ本身，负责转发消息、持久化消息等。</li>
<li>Consumer：消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。</li>
</ol>
<h2 id="消息被消费后会立即删除吗"><a href="#消息被消费后会立即删除吗" class="headerlink" title="消息被消费后会立即删除吗"></a>消息被消费后会立即删除吗</h2><p>不会，每条消息都会持久化到CommitLog中，每个Consumer连接到Broker后会维持消费进度消息，当有消息消费后CommitLog的offerset就更新了。</p>
<h2 id="消息堆积后什么时候会清理过期消息，如何处理"><a href="#消息堆积后什么时候会清理过期消息，如何处理" class="headerlink" title="消息堆积后什么时候会清理过期消息，如何处理"></a>消息堆积后什么时候会清理过期消息，如何处理</h2><p>4.6版本默认48小时候会删除不再使用的commitLog文件。检查这个文件最后的访问时间，并判断是否大于过期时间，指定时间删除，默认凌晨4点。</p>
<h2 id="消息堆积会不会进入到死信队列"><a href="#消息堆积会不会进入到死信队列" class="headerlink" title="消息堆积会不会进入到死信队列"></a>消息堆积会不会进入到死信队列</h2><p>不会，消息在消费失败之后会进入重试队列，默认重试16次才会进入死信队列。</p>
<h2 id="死信队列的作用以及队列里消息的保存时间"><a href="#死信队列的作用以及队列里消息的保存时间" class="headerlink" title="死信队列的作用以及队列里消息的保存时间"></a>死信队列的作用以及队列里消息的保存时间</h2><p>死信队列用于存储消费失败的消息，消息消费失败重试次数达到阈值默认是16次会放入死信队列，死信队列中的消息默认保存时间是72小时，你可以在消息队列控制台查询消息以及重发死信队列中的消息。</p>
<ol>
<li>代码正常执行返回消息状态为CONSUME_SUCCESS，执行异常返回RECONSUME_LATER</li>
<li>状态为RECONSUME_LATER的消息会进入到重试队列，重试队列的名称为 %RETRY% + ConsumerGroupName；</li>
<li>重试16次消息任然没有处理成功，消息就会进入到死信队列%DLQ% + ConsumerGroupName;</li>
</ol>
<h2 id="消息消费的模式"><a href="#消息消费的模式" class="headerlink" title="消息消费的模式"></a>消息消费的模式</h2><ul>
<li>集群消费：一条消息只会被一个Group中的一个Consumer消费</li>
<li>广播消费：多个Group同时消费一个Topic时，每个Group中的Consumer都会消费这条数据。</li>
</ul>
<h2 id="Broker如何处理pull请求的"><a href="#Broker如何处理pull请求的" class="headerlink" title="Broker如何处理pull请求的"></a>Broker如何处理pull请求的</h2><p>Consumer首次请求Broker</p>
<ul>
<li><p>Broker中是否有符合条件的消息</p>
</li>
<li><p>有 -&gt;</p>
</li>
<li><ul>
<li>响应Consumer</li>
<li>等待下次Consumer的请求</li>
</ul>
</li>
<li><p>没有</p>
</li>
<li><ul>
<li>DefaultMessageStore#ReputMessageService#run方法</li>
<li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li>
<li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li>
<li>当有新消息的时候返回请求</li>
<li>挂起consumer的请求，即不断开连接，也不返回数据</li>
</ul>
</li>
</ul>
<h2 id="如何做负载均衡"><a href="#如何做负载均衡" class="headerlink" title="如何做负载均衡"></a>如何做负载均衡</h2><p>RocketMQ中的负载均衡都在Client端完成，具体来说，主要可以分为Producer端发送消息时的负载均衡和Consumer端订阅消息的负载均衡。消费消息的方式push&amp;pull实际上均由pull模式实现，所以具体负载均衡是在客户端完成的。核心类—RebalanceImpl 在Consumer启动的过程中会完成RebalanceService启动，每20s执行一次，最终调用RebalanceImpl来实现。</p>
<h2 id="如何避免重复消费"><a href="#如何避免重复消费" class="headerlink" title="如何避免重复消费"></a>如何避免重复消费</h2><ul>
<li>数据库表中定义为以约束，如果有重复数据插入报唯一键冲突</li>
<li>Redis设置全局唯一业务ID，处理前查一下，如果有的话就不处理，否则在处理后面逻辑。</li>
<li>分布式锁</li>
</ul>
<h2 id="如何保证有序消费"><a href="#如何保证有序消费" class="headerlink" title="如何保证有序消费"></a>如何保证有序消费</h2><p>首先多个队列只能保证单个队列中的消息有序，同一个topic同一个队列发消息的时候一个线程发送，消费的时候单线程消费。</p>
<p>发送消息通过id对队列个数取余保证同一个消息发送到同一个queue。</p>
<h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><ul>
<li>Producer：采取send()同步发送消息，发送结果是同步感知的，发送失败可以重试，默认重试3次。</li>
<li>broker：修改刷盘策略为同步刷盘，默认是异步刷盘。集群部署，主从模式，高可用</li>
<li>consumer：完全消费后手动ACK确认。</li>
</ul>
<h2 id="RocketMQ分布式事务的原理"><a href="#RocketMQ分布式事务的原理" class="headerlink" title="RocketMQ分布式事务的原理"></a>RocketMQ分布式事务的原理</h2><p>事务消息处理流程</p>
<p><img src="/posts/3e7adddd/image.png" alt="img"></p>
<p>事务消息的生命周期</p>
<p><img src="/posts/3e7adddd/image.png" alt="img"></p>
<p>事务消息的使用限制</p>
<ul>
<li>事务消息仅支持在<strong>MessageType</strong>为<strong>Transaction</strong>的主题内使用，即事务消息只能发送至类型为事务消息的主题中，发送的消息的类型必须和主题的类型一致。</li>
<li>RocketMQ事务消息保证最终一致性，但是上下游系统事务之间的中间状态不一定一致。</li>
<li>如果Half Message发送到Broker之后，如果在指定时间内服务端无法确认提交或者回滚状态，则消息默认会被回滚。</li>
</ul>
<h2 id="如何优化性能（Producer和Consumer）"><a href="#如何优化性能（Producer和Consumer）" class="headerlink" title="如何优化性能（Producer和Consumer）"></a>如何优化性能（Producer和Consumer）</h2><ul>
<li>同一个消费者组，多台机器部署，并行消费</li>
<li>单个Consumer提高消费线程个数</li>
<li>批量消费（消息批量拉取，业务逻辑批量处理）</li>
<li>Page Cache，JVM调优，多线程</li>
</ul>
<h2 id="NameServer的作用"><a href="#NameServer的作用" class="headerlink" title="NameServer的作用"></a>NameServer的作用</h2><p>Broker的信息（IP，topic对应）会注册到所有的NameServer。</p>
<h2 id="Broker宕机了怎么办"><a href="#Broker宕机了怎么办" class="headerlink" title="Broker宕机了怎么办"></a>Broker宕机了怎么办</h2><p>Broker主从架构以及多副本策略，Master收到消息后同步给Slave，这样消息不止一份，可以保证MQ的可靠性和高可用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ynyhl/p/11320797.html">kafka和RocketMQ对比</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">github:RocketMQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/javazhiyin/p/13327925.html">https://www.cnblogs.com/javazhiyin/p/13327925.html</a></p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/440244.html">https://help.aliyun.com/document_detail/440244.html</a></p>

    </div>

    
    
    <div class="post-widgets">
    <div
      class="social-share"
      
        data-sites="weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google"
      
      
        data-wechat-qrcode-title="share.title"
      
      
        data-wechat-qrcode-helper="share.prompt"
      
    >
    </div>
  </div>
  <script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js"></script>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Author
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://itdatao.github.io/posts/3e7adddd/" title="rocketmq">http://itdatao.github.io/posts/3e7adddd/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/rocketMQ/" rel="tag"><i class="fa fa-tag"></i> rocketMQ</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/5bbc7517/" rel="prev" title="kafka">
      <i class="fa fa-chevron-left"></i> kafka
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/232196e/" rel="next" title="elastic search">
      elastic search <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RocketMQ"><span class="nav-number">1.</span> <span class="nav-text">RocketMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMQ%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是MQ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">MQ有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84MQ%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.3.</span> <span class="nav-text">不同的MQ的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.4.</span> <span class="nav-text">作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E6%B5%81%E5%89%8A%E5%B3%B0"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">限流削峰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%A7%A3%E8%80%A6"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">异步解耦</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">数据收集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">消息模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.2.</span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topic%E4%B8%BB%E9%A2%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">Topic主题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tag"><span class="nav-number">1.2.4.</span> <span class="nav-text">Tag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer"><span class="nav-number">1.2.5.</span> <span class="nav-text">Producer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer"><span class="nav-number">1.2.6.</span> <span class="nav-text">Consumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Broker-Server"><span class="nav-number">1.2.7.</span> <span class="nav-text">Broker Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Name-Server"><span class="nav-number">1.2.8.</span> <span class="nav-text">Name Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%89%E5%8F%96%E5%BC%8F%E6%B6%88%E8%B4%B9"><span class="nav-number">1.2.9.</span> <span class="nav-text">拉取式消费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E5%8A%A8%E5%BC%8F%E6%B6%88%E8%B4%B9"><span class="nav-number">1.2.10.</span> <span class="nav-text">推动式消费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%BB%84"><span class="nav-number">1.2.11.</span> <span class="nav-text">生产者组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="nav-number">1.2.12.</span> <span class="nav-text">消费者组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9"><span class="nav-number">1.2.13.</span> <span class="nav-text">集群消费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9"><span class="nav-number">1.2.14.</span> <span class="nav-text">广播消费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.15.</span> <span class="nav-text">普通顺序消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.16.</span> <span class="nav-text">严格顺序消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="nav-number">1.3.1.</span> <span class="nav-text">消息的订阅与发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%89%E5%BA%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">消息的有序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E8%BF%87%E6%BB%A4"><span class="nav-number">1.3.3.</span> <span class="nav-text">消息的过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.3.4.</span> <span class="nav-text">对消息可靠性的影响因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%B3%E5%B0%91%E4%B8%80%E6%AC%A1%EF%BC%88At-least-once%EF%BC%89"><span class="nav-number">1.3.5.</span> <span class="nav-text">至少一次（At least once）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B6%88%E8%B4%B9"><span class="nav-number">1.3.6.</span> <span class="nav-text">回溯消费</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%92%8C%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF"><span class="nav-number">1.3.7.</span> <span class="nav-text">事务消息和定时消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95"><span class="nav-number">1.3.8.</span> <span class="nav-text">消息重试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E6%8A%95"><span class="nav-number">1.3.9.</span> <span class="nav-text">消息重投</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.10.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">1.3.11.</span> <span class="nav-text">什么是死信队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="nav-number">1.4.</span> <span class="nav-text">顺序消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="nav-number">1.5.</span> <span class="nav-text">延时消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">1.6.</span> <span class="nav-text">消息的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">1.7.</span> <span class="nav-text">消息的高可用性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">1.7.1.</span> <span class="nav-text">消费端高可用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">1.7.2.</span> <span class="nav-text">发送端高可用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.8.</span> <span class="nav-text">消息的主从复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">1.9.</span> <span class="nav-text">通信机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.10.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.10.1.</span> <span class="nav-text">Producer的负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.10.2.</span> <span class="nav-text">Consumer的负载均衡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="nav-number">1.11.</span> <span class="nav-text">事务消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E3%80%82"><span class="nav-number">1.11.1.</span> <span class="nav-text">事务消息的发送与提交流程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Op%E6%B6%88%E6%81%AF%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">1.11.2.</span> <span class="nav-text">Op消息的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Op%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">1.11.3.</span> <span class="nav-text">Op消息的存储和对应关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Half%E6%B6%88%E6%81%AF%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA"><span class="nav-number">1.11.4.</span> <span class="nav-text">Half消息的索引构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2PC%E5%A4%B1%E8%B4%A5%E6%97%B6%E6%B6%88%E6%81%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">1.11.5.</span> <span class="nav-text">2PC失败时消息该如何处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.12.</span> <span class="nav-text">消息的查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">常见面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">MQ的作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E7%9A%84%E8%A7%92%E8%89%B2%E7%BB%84%E6%88%90%E4%BB%A5%E5%8F%8A%E5%90%84%E4%B8%AA%E8%A7%92%E8%89%B2%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">RocketMQ的角色组成以及各个角色的作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%A2%AB%E6%B6%88%E8%B4%B9%E5%90%8E%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%88%A0%E9%99%A4%E5%90%97"><span class="nav-number">2.3.</span> <span class="nav-text">消息被消费后会立即删除吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%90%8E%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%B8%85%E7%90%86%E8%BF%87%E6%9C%9F%E6%B6%88%E6%81%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">2.4.</span> <span class="nav-text">消息堆积后什么时候会清理过期消息，如何处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%BF%9B%E5%85%A5%E5%88%B0%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">2.5.</span> <span class="nav-text">消息堆积会不会进入到死信队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%98%9F%E5%88%97%E9%87%8C%E6%B6%88%E6%81%AF%E7%9A%84%E4%BF%9D%E5%AD%98%E6%97%B6%E9%97%B4"><span class="nav-number">2.6.</span> <span class="nav-text">死信队列的作用以及队列里消息的保存时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.7.</span> <span class="nav-text">消息消费的模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broker%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86pull%E8%AF%B7%E6%B1%82%E7%9A%84"><span class="nav-number">2.8.</span> <span class="nav-text">Broker如何处理pull请求的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">2.9.</span> <span class="nav-text">如何做负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="nav-number">2.10.</span> <span class="nav-text">如何避免重复消费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="nav-number">2.11.</span> <span class="nav-text">如何保证有序消费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="nav-number">2.12.</span> <span class="nav-text">如何保证消息不丢失</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.13.</span> <span class="nav-text">RocketMQ分布式事务的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%EF%BC%88Producer%E5%92%8CConsumer%EF%BC%89"><span class="nav-number">2.14.</span> <span class="nav-text">如何优化性能（Producer和Consumer）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NameServer%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.15.</span> <span class="nav-text">NameServer的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broker%E5%AE%95%E6%9C%BA%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">2.16.</span> <span class="nav-text">Broker宕机了怎么办</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="https://s2.loli.net/2023/02/26/PVfcsSojHARqp1y.jpg">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/itdatao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;itdatao" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://huitao233@gmail.com/" title="E-Mail → https:&#x2F;&#x2F;huitao233@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">57k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">52 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '68ae00996366cbfe27b7',
      clientSecret: '0a2d65cea9a9024872be4217ddf0af3d4d017ba0',
      repo        : 'blog-comments',
      owner       : 'itdatao',
      admin       : ['itdatao'],
      id          : 'f09ad668f12377fb0dd199b8c6512922',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
