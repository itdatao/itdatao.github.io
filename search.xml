<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL45讲笔记</title>
    <url>/posts/c24675b4/</url>
    <content><![CDATA[<p>SQL语句执行流程，redo log,bin log的区别，bin log的写入过程，以及写入格式类型有哪些？MySQL如何实现高可用，高性能，主备延迟是怎么来的？事务隔离级别的实现，索引的数据结构，覆盖索引，索引下推，锁类型有哪些？等等</p>
<span id="more"></span>

<h2 id="一条SQL语句是如何执行的"><a href="#一条SQL语句是如何执行的" class="headerlink" title="一条SQL语句是如何执行的"></a>一条SQL语句是如何执行的</h2><h2 id="redolog-binlog的区别"><a href="#redolog-binlog的区别" class="headerlink" title="redolog binlog的区别"></a>redolog binlog的区别</h2><h2 id="MySQL事务的隔离级别的实现"><a href="#MySQL事务的隔离级别的实现" class="headerlink" title="MySQL事务的隔离级别的实现"></a>MySQL事务的隔离级别的实现</h2><h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><h2 id="InnoDB和MyIsam存储引擎的区别"><a href="#InnoDB和MyIsam存储引擎的区别" class="headerlink" title="InnoDB和MyIsam存储引擎的区别"></a>InnoDB和MyIsam存储引擎的区别</h2><h2 id="MVCC快照的实现"><a href="#MVCC快照的实现" class="headerlink" title="MVCC快照的实现"></a>MVCC快照的实现</h2><h2 id="什么时候会用到内部临时表"><a href="#什么时候会用到内部临时表" class="headerlink" title="什么时候会用到内部临时表"></a>什么时候会用到内部临时表</h2><h2 id="一张表数据导入到另一张表的方法"><a href="#一张表数据导入到另一张表的方法" class="headerlink" title="一张表数据导入到另一张表的方法"></a>一张表数据导入到另一张表的方法</h2><h2 id="自增ID用完后会出现什么问题？"><a href="#自增ID用完后会出现什么问题？" class="headerlink" title="自增ID用完后会出现什么问题？"></a>自增ID用完后会出现什么问题？</h2>]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo</title>
    <url>/posts/37e41c9c/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>elastic search</title>
    <url>/posts/232196e/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>effective Java</title>
    <url>/posts/21283aa4/</url>
    <content><![CDATA[<p>创建和销毁对象，对象通用的方法，类和接口的设计，枚举注解，泛型，方法，通用设计等。</p>
<span id="more"></span>

<h1 id="第一章-创建和销毁对象"><a href="#第一章-创建和销毁对象" class="headerlink" title="第一章 创建和销毁对象"></a>第一章 创建和销毁对象</h1><h2 id="1-考虑用静态代替构造方法"><a href="#1-考虑用静态代替构造方法" class="headerlink" title="1. 考虑用静态代替构造方法"></a>1. 考虑用静态代替构造方法</h2><p>想要获取一个类的实例，一种传统的方式是通过共有的构造器，当然还可以使用另一种技术：提供共有的静态工厂方法。</p>
<!--more-->

<p>什么是静态工厂？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要用静态工厂替换构造方法？有什么优点</p>
<ol>
<li>静态工厂相比构造器来讲，有名字并且通俗易懂，构造器的名字必须和类名一致</li>
<li>静态工厂每次调用不必新建对象。所以适用于不可变的类，单例，初始化就缓存好，避免重复创建。</li>
<li>静态工厂方法能够返回原先返回类型的任意子类型的对象，更加灵活的选择返回对象。例如Collection有32个实现类在Collections中可以返回。</li>
<li>静态工厂可以根据调用传入的不同参数返回不同的对象。</li>
</ol>
<p>静态工厂的不足之处？</p>
<ol>
<li>静态工厂没有public和protected的方法，因此不能被子类化。</li>
</ol>
<p>一般静态工厂方法名字的含义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fromValue(value) <span class="comment">//这种通过传入单个参数返回相应类型的实例对象</span></span><br><span class="line">of(v1,v2,v3) <span class="comment">// 传入多个参数，返回报站这些参数的实例。</span></span><br><span class="line"><span class="comment">// valueOf是from of更详细的替代方案</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">prime</span> <span class="operator">=</span> BigInteger.valueOf(Integer.MAX_VALUE);</span><br><span class="line"><span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(classObject, arrayLen);<span class="comment">//每次返回的对象都是新的实例</span></span><br></pre></td></tr></table></figure>

<h2 id="2-当遇到多个构造器使用构建者"><a href="#2-当遇到多个构造器使用构建者" class="headerlink" title="2. 当遇到多个构造器使用构建者"></a>2. 当遇到多个构造器使用构建者</h2><p>构造方法和静态工厂共有的限制：不能很好的扩展很多可选参数的场景 。因此对于多个可选参数，考虑使用构建者模式。</p>
<p>其实对于等多个可选参数可以使用新建JavaBean 使用set方法创建实例，这样更通俗易懂但是会很冗长。</p>
<p>builder结合了构造方法的安全性和JavaBean 模式的可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span>      <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span>           <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="built_in">this</span>.servings    = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> val)</span> &#123; </span><br><span class="line">            calories = val;      </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> val)</span> &#123; </span><br><span class="line">           fat = val;           </span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        servingSize  = builder.servingSize;</span><br><span class="line">        servings     = builder.servings;</span><br><span class="line">        calories     = builder.calories;</span><br><span class="line">        fat          = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保多个参数的不变性不受攻击，可以在builder复制参数后对对象属性进行检查。检查失败抛出非法参数异常（IllegalArgumentException）。</p>
<p>单个builder可以重复使用构建多个不同的对象，对象的参数可以灵活调整，适用多个可选参数。</p>
<p>协变返回类型：一个子类的方法被声明为返回在父类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。（这个比较有意思）</p>
<h2 id="3-使用私有构造器或者枚举实现单例"><a href="#3-使用私有构造器或者枚举实现单例" class="headerlink" title="3. 使用私有构造器或者枚举实现单例"></a>3. 使用私有构造器或者枚举实现单例</h2><p>单例对象通常表示无状态，不可变对象。</p>
<p>实现单例的几种方式，其中枚举方式最佳，无偿提供了序列化机制，防止多个实例化。可以阻止反射创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例模式的实现方式一 Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="comment">// 公共静态成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式的实现方式二 Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 每次调用该方法否返回同一个对象引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式的实现方式三 Enum singleton - the preferred approach（最佳方式）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">     <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化过程中为了保证单例不被破坏，生命所有的字段为transient，并提供readResolve方法。否则当序列化实例被反序列化时，就会创建一个新的实例。</p>
<h2 id="4-使用私有构造器实现非实例化"><a href="#4-使用私有构造器实现非实例化" class="headerlink" title="4. 使用私有构造器实现非实例化"></a>4. 使用私有构造器实现非实例化</h2><p>试图通过创建抽象类来实现非实例化是行不通的，因为该类的子类可以被实例化，并且他还可能会误导用户该类是为了继承而设计的。因此使用简单的方式——私有化构造函数实现类的非实例化。</p>
<h2 id="5-依赖注入优于硬链接资源"><a href="#5-依赖注入优于硬链接资源" class="headerlink" title="5. 依赖注入优于硬链接资源"></a>5. 依赖注入优于硬链接资源</h2><p>当多个类依赖于同一个或者多个底层资源时，静态工具和单例模式对于这种场景是不适用的。因为这两种方式再并发场景中变得不可用，更容易出错。</p>
<p>其实每个实例在使用客户端的资源时，可以在创建时将资源的参数传入构造函数中，这就是依赖注入的一种形式（构造方法注入）。这种方式保证了资源的不可变性，依赖注入不仅适用于构造器，也同样适用于静态工厂和Builder。Supplier<T>这个接口就可以很好的标识这些工厂，客户端传入一个工厂，工厂负责创建指定类型的实例。</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如生成马赛克的工厂</span></span><br><span class="line">Mosaic <span class="title function_">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入可以大幅度提升类的灵活性，可测试性，复用性。</p>
<h2 id="6-避免创建不必要的对象"><a href="#6-避免创建不必要的对象" class="headerlink" title="6. 避免创建不必要的对象"></a>6. 避免创建不必要的对象</h2><p>如果一个对象是不可变的，那么他总能被复用，复用相比于新建更快速。</p>
<p>当不可变类同时提供了构造器和静态工厂方法时，优先使用静态方法来避免创建不必要对象。</p>
<p>自动装箱可能会创建不必要的对象，他模糊了基本类型和装箱类型之间的区别，但是没有消除这种区别，有可能会导致一些性能问题，因此优先使用基本类型而不是装箱类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        <span class="comment">// Long =&gt; long</span></span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意相比于创建新对象，复用的代价更高，如果没能暴增拷贝安全，将会导致潜在的bug和安全漏洞。</p>
<h2 id="7-消除过时的对象引用"><a href="#7-消除过时的对象引用" class="headerlink" title="7. 消除过时的对象引用"></a>7. 消除过时的对象引用</h2><p>内存泄漏：指程序再申请内存后，无法释放已申请的内存空间，内存泄漏堆积后就会发生内存溢出。</p>
<p>内存溢出：报错OOM，没有足够的内存供申请者使用。</p>
<p>一般来讲当一个类自己管理自己的内存时，程序员就要注意内存内存泄露问题了，只要一个元素被释放了，那这个元素包含的所有对象应用都应该被清空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// Eliminate obsolete reference help gc</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消除过期引用的最佳方式是将每个变量定义在最小的作用域中。</p>
<p>缓存是内存泄漏的另一个来源。当将一个对象放到缓存中取，时间长了很容易忘记他还在那，剞劂方法可以使用WeakHashMap来充当缓存，只要key过期后就会被自动清除。</p>
<h2 id="8-避免使用终结方法和清理方法"><a href="#8-避免使用终结方法和清理方法" class="headerlink" title="8. 避免使用终结方法和清理方法"></a>8. 避免使用终结方法和清理方法</h2><p>在Java9中，finalizers方法已经过时了，替代的是清理方法，清理方法比终结方法危险性更低，但仍然是不可预测的，性能比较低，并且也是非必要不使用。</p>
<p>不使用的原因：</p>
<ul>
<li>终结方法和清理方法的缺点在于不能保证被及时执行或会被执行，当一个对象变得不可达，到执行终结方法或清理方法时，这个时间段是任意长的。因此当有对时间要求的任务不应该调用终结或清理方法完成，不应该依赖终结方法或者清理方法来更新重要的持久态。</li>
<li>终结方法的另一个问题是在终结过程中会忽略掉抛出的异常，并且不会打印线程终止的堆栈信息。如果另一个线程企图使用这种未捕获异常的对象可能会发生不确定的行为。</li>
<li>终结方法和清理方法会严重影响性能。</li>
</ul>
<p>清理方法和终结方法的两种用途：</p>
<ol>
<li>当对象的持有者忘记调用终止方法的情况下充当安全网。如 FileInputStream、FileOutputStream、ThreadPoolExecutor、和 java.sql.Connection具有充当安全网终结方法。</li>
<li>本地对灯体是普通对象通过本机方法委托的非Java对象，因为本地对等体不是普通Java对象，因此垃圾收集器不会识别它，当性能可接受且本地对等体没有关键的资源，则可以用清理或者终结方法回收。</li>
</ol>
<h2 id="9-使用try-with-resources代替try-finally"><a href="#9-使用try-with-resources代替try-finally" class="headerlink" title="9. 使用try-with-resources代替try-finally"></a>9. 使用try-with-resources代替try-finally</h2><p>Java中有许多必须通过调用close方法手动关闭的资源，比如InputStream,OutputStream.</p>
<p>在之前，即使是程序抛出异常或者返回的情况下，try-finally是保证资源正确关闭的最佳方式。但是当处理多个资源关闭时，情况就会变糟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">                out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span>   <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst)) &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">            out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，当最里层的finally的close方法关闭失败，外层的的异常就会覆盖掉里层的异常，导致调试过程会很困难。但使用try-with-resourses就可以避免这个问题，并且try-with-resourses代码更加简洁易读。</p>
<h1 id="第二章-所有对象都通用的方法"><a href="#第二章-所有对象都通用的方法" class="headerlink" title="第二章 所有对象都通用的方法"></a>第二章 所有对象都通用的方法</h1><h2 id="10-覆盖equals方法时请遵守通用约定"><a href="#10-覆盖equals方法时请遵守通用约定" class="headerlink" title="10. 覆盖equals方法时请遵守通用约定"></a>10. 覆盖equals方法时请遵守通用约定</h2><p>因为Object主要是为继承设计的，它的所有非final方法都有清晰地约定，任何类要重写这些方法时，都有义务去遵守这些约定否则其他依赖这些约定的类就不会正常工作。</p>
<p>什么时候不需要覆盖equals方法？</p>
<ul>
<li>每个类的实例都是固有唯一的。如Thread</li>
<li>类不需要提供逻辑相等的功能。</li>
<li>父类已经重写过equals方法，父类的行为完全适合子类。</li>
<li>类是私有的，并且equals方法永远不会被调用。</li>
</ul>
<p>什么时候需要重写equals方法？</p>
<p>如果一个类需要一个逻辑相等的概念，并且父类没有重写过这个方法，需要在该类中重写equals方法。通常这种类是值类。如Integer，String。</p>
<p>重写equals方法必须遵守的约定。</p>
<ol>
<li>自反性：对任何费控引用x,x.equals(x)必须返回true。</li>
<li>对称性：对于任何非空引用x和y，如果y.equals(x)=true，则x.equals(y)=true</li>
<li>传递性: x,y,z都不为null，如果x.equals(y)=true，y.equals(z)=true，则z.equals(x)=true。</li>
<li>一致性：如果x,y非空，并且equals比较中的信息没有修改，多次调用x.equals(y)都要始终返回true或false。</li>
<li>对任何非空引用x,x.equals(null)必须返回false。</li>
</ol>
<p>重写equals方法时，要重写hashCode方法，不要让equals方法干太多事，不要将Object参数类型替换成其他类型。</p>
<h2 id="11-重写equals方法时总要重写hashCode"><a href="#11-重写equals方法时总要重写hashCode" class="headerlink" title="11. 重写equals方法时总要重写hashCode"></a>11. 重写equals方法时总要重写hashCode</h2><p>重写equals方法必须重写hashCode方法，如果没有重写，在使用HasMap或HashSet时无法正常运作。</p>
<p>重写的equals方法必须遵守 Object 中指定的规定。</p>
<ul>
<li>在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode 方法都必须始终如一地返回相同的值。</li>
<li>如果两个对象调用 equals（Object）方法比较是相等的，那么调用这两个对象中任意一个对象的 hashCode 方法都必须产生相同的整数结果。</li>
<li>如果两个对象根据 equals（Object）方法比较是不相等的，那么调用这两个对象中任意一个对象的 hashCode 方法，则不一定要产生不同的结果。无论如何，开发者应该知道，不相等的对象产生截然不同的结果，有可能提高散列表（hash tables）的性能。</li>
</ul>
<h2 id="12-始终覆盖toString"><a href="#12-始终覆盖toString" class="headerlink" title="12. 始终覆盖toString"></a>12. 始终覆盖toString</h2><p>默认的Object的toString方法返回的是：类名+@+无符号16进制散列码。</p>
<p>toString 方法应该返回对象中包含的所有值得关注的信息。</p>
<p>在实现toString时，需要判断是否处理返回值的格式。</p>
<ul>
<li>指定字符串的格式的好处：更易读。</li>
<li>指定字符串的格式的坏处：一旦被广泛使用，必须始终坚持这种格式。如果改变格式，将会破坏代码和数据。</li>
</ul>
<p>无论是否指定格式，<strong>都为 toString 返回值中包含的所有信息，提供一种编程式的访问路径。否则不得不自己去解析，解析过程可能会出错。</strong></p>
<h2 id="13-谨慎覆盖clone"><a href="#13-谨慎覆盖clone" class="headerlink" title="13. 谨慎覆盖clone"></a>13. 谨慎覆盖clone</h2><p>假设我们需要为一个类实现Cloneable接口，这个类的父类提供了一个良好的clone方法。我们从super.clone中得到的对象将会是原始对象的一个完整克隆。类中声明的任一属性的值将会和原始类对应的属性的值相等。如果每个属性包含了基本类型值或者不过变对象的引用，那么返回的对象可能正是我们要的，在这种情况下，不需要进一步的处理。</p>
<p>如果一个类它的所有父类获取clone的对象是通过调用super.clone，那么<em>x.clone().getClass() == x.getClass()。</em></p>
<p>对于不可变的类不应该提供clone方法，因为这会造成无意义的拷贝。对于final修饰的属性，克隆不会成功因为禁止向final修饰的属性二次赋值。</p>
<p><strong>实际上，clone方法就是另一个构造器，我们必须保证它不会破坏原始对象而且能恰当创建被克隆对象的约束条件。</strong></p>
<h2 id="14-考虑是否实现comparable"><a href="#14-考虑是否实现comparable" class="headerlink" title="14. 考虑是否实现comparable"></a>14. 考虑是否实现comparable</h2><p>compareTo方法并没有在Object里被声明，而是在Comparable接口中声明的唯一方法。</p>
<p>假如一个类实现了Comparable接口，那就表明了这个类的各个实例之间是有顺序的。几乎所有的Java类库，包括枚举类型（条目34），都实现了Comparable接口。</p>
<p>在下面的表述中，符号sgn（expression）表示数学中的signum函数，返回值为-1，0，1。</p>
<ul>
<li>实现类必须确保对于所有的x和y，sgn(x.compareTo(y)) == -sgn(y. compareTo(x))成立。（这意味着，当且仅当y.compareTo(x)抛出了异常，x.compareTo(y)也必须抛出异常。）（自反性）</li>
<li>实现类必须确保关系的传递性：若(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)，则x.compareTo(z)&gt;0。</li>
<li>最后，实现类必须确保若x.compareTo(y) == 0，则对于所有的z，sgn(x.compareTo(z)) == sgn(y.compareTo(z))成立。（一致性）</li>
<li>强烈建议(x.compareTo(y) == 0) == (x.equals(y))成立，但这并不是必须的，通常来说，任何实现了Comparable接口的类如果违反了这个条件，那么应该做个说明。推荐的说法是“注意：该类具有自然排序，但是与equals方法不一致。”</li>
</ul>
<p>当遇到不同类型的实例比较时，会抛出ClassCastException异常。</p>
<p>在compareTo方法里，我们对属性进行比较是为了得到一个顺序而不是看其是否相等。为了比较对象引用的属性，我们可以递归地调用compareTo方法。如果一个属性没有实现Comparable接口或者我们需要一个非标准的顺序，可以使用Comparator来替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">.thenComparingInt(pn -&gt; pn.prefix)  </span><br><span class="line">.thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhoneNumber pn)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> COMPARATOR.compare(<span class="built_in">this</span>, pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareTo或compare方法依赖于两个值之间的差值，若第一个值小于第二个值，则为负，若两个值相等，则为0，若第一个值大于第二个值，则为正。在实现compareTo方法时，避免使用 &lt; 和 &gt; 运算符来进行属性值的比较。相反，我们应该使用封箱基本类型的静态比较方法（例如Integer.compare），或者Comparator接口里的比较器构造方法（例如Comparator<Object> hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());）。</Object></p>
<h1 id="第三章-类和接口"><a href="#第三章-类和接口" class="headerlink" title="第三章 类和接口"></a>第三章 类和接口</h1><h2 id="15-最小化类和成员的访问性"><a href="#15-最小化类和成员的访问性" class="headerlink" title="15. 最小化类和成员的访问性"></a>15. 最小化类和成员的访问性</h2><p>封装：尽量让每个类或者成员尽可能的不可访问。</p>
<p>如果一个顶层的类或者接口的访问修饰符是private，那么后续你可以修改，替换甚至删除他，而不必担心损害现有的方法，如果是public就需要永远支持，保证兼容性。</p>
<p>如果想要测试代码，需要访问一个类的方法，将private-&gt;default是可接受的，但是提高到更高的访问级别是不可接受的。</p>
<ul>
<li>public类中的成员变量尽量不应该也是public。</li>
<li>对于公有静态常量命名通常是大写字母组成，单词之间通过下划线分开。</li>
<li>让一个类具有共有静态数组，或者返回这种数组的方法是不可取的，因为客户端调用时可以随意修改数组的内容是一个安全漏洞。（确保被公有静态final域引用的对象是不可变的）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 可以改为如下,public -&gt; private 同时添加公有不可变的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)) ;</span><br></pre></td></tr></table></figure>

<h2 id="16-在公有类中使用访问方法而不是公有域"><a href="#16-在公有类中使用访问方法而不是公有域" class="headerlink" title="16. 在公有类中使用访问方法而不是公有域"></a>16. 在公有类中使用访问方法而不是公有域</h2><ul>
<li>公有类应该永远都不要暴露可变域。因为在暴漏之后如果想要更改数据域的字段时就会牵一发而动全身。（客户端代码已经在各处使用了）</li>
<li>对于公有类暴露不可变域的情况，虽然危害小一些，但也仍是有问题的。</li>
<li>如果一个类在包外可以被访问，就应该提供访问方法</li>
</ul>
<h2 id="17-可变性最小化"><a href="#17-可变性最小化" class="headerlink" title="17. 可变性最小化"></a>17. 可变性最小化</h2><p>不可变类的好处：更安全，不容易出错，容易使用。（如String,BigDecimal等）</p>
<ol>
<li>不可变对象天然是线程安全的，不要求同步，不可变对象可以被自由共享，通常也是被static修饰的。</li>
<li>不可变对象为其他对象提供了大量的构件，可以作为map的key,集合的元素，不会破坏考核或者map这种不变性.</li>
<li>不可变对象提供了免费的失败原子机制。状态不会出现临时的不一致性。</li>
</ol>
<p>实现不可变类遵循的几个规则：</p>
<ol>
<li>不提供修改对象状态的方法。如setter</li>
<li>确保这个类不能被继承。用final修饰，阻止子类改变对象的状态，从而破坏不可变性。</li>
<li>所有数据域设置为private final，一个实例在线程之间传递确保正确，并防止对象被修改。</li>
<li>确保对任务可变组件的互斥访问。</li>
</ol>
<p>缺点是：对于大对象来讲，每个不同的值都需要一个对应的对象。创建对象的成本会很高。</p>
<p>解决方法：</p>
<ol>
<li>对于创建中重复的步骤，可以用基本数值类型来代替，这样不用每个步骤创建一个对象。</li>
<li>创建一个公有的伙伴类，类似于String和StringBuilder的关系。</li>
</ol>
<p>注意：如果不可变类实现了序列化接口，同时不可变类还包含了对个指向可变对象的引用，这时候需要显示提供一个readObject方法和readResolve方法，不然攻击者可以通过反序列化方式创建该类的可变实例。</p>
<p>不要每写一个getter就要冲动着去写一个对应的setter。<strong>类应该都是不可变的，除非有个很好的理由需要它们是可变的，如果一个类不能做成不可变，那就尽可能限制它的可变性。这样可以减少出现的错误。</strong></p>
<p><strong>构造器应该完全初始化对象，并建立好不变性。</strong>除非有很强的理由，否则不要在构造器或静态方法之外还提供公有初始化方法。</p>
<h2 id="18-组合优于继承"><a href="#18-组合优于继承" class="headerlink" title="18. 组合优于继承"></a>18. 组合优于继承</h2><p>继承是复用代码的方式，但同时也违反了封装原则。子类需要依赖父类的实现来实现自己的功能。如果父类产生变化，子类将会被破坏，需要跟着父类一起演化。</p>
<p>继承只适用于一个类的类型的确是某个父类的子类型的情况。换句话说，只有当类B和类A是“is-a”的关系时，类B才应该扩展类A。是否每个B都确实是一个A？如果你对这个问题无法肯定地回答yes，那么B就不应该扩展A。</p>
<p>如果子类在一个与父类不同的包中且父类本来就不是设计来被继承的，那么继承将会导致子类的脆弱性。为了避免这种脆弱性，我们应该使用组合与转发，而不是继承，尤其是存在一个适当的接口来实现一个现存的包装者类。包装者类不仅比子类更健壮，而且更强大。</p>
<h2 id="19-要么涉及继承提供文档，要么禁止继承"><a href="#19-要么涉及继承提供文档，要么禁止继承" class="headerlink" title="19. 要么涉及继承提供文档，要么禁止继承"></a>19. 要么涉及继承提供文档，要么禁止继承</h2><p>一个类的文档必须说明在哪些情况下它会调用可子类的覆盖方法。例如，调用可能来自后台线程或者静态初始器。</p>
<p>文档明确说明覆盖迭代方法将会产生的影响，描述方法是怎么做的。这便是继承复杂的一点。</p>
<p>测一个被继承类的唯一方式是编写子类，如果忽略某个保护成员，就会出现问题，在子类中暴漏出来。</p>
<p>如果一个了类允许被继承，必须有约束条件需要遵循。</p>
<ol>
<li>构造函数中一定不要调用可覆盖的方法。否则会导致程序失败。</li>
<li>如果决定让设计被继承的类实现Serializable接口，而且这个类拥有readResolve方法或writeReplace方法，你一定要把readResolve方法或writeReplace方法设为受保护的，而不是私有的。</li>
</ol>
<p>如果某个类的确是要被子类化，否则最好将类声明为final或者保证其没有可访问的构造器来禁止该类被继承。</p>
<h2 id="20-接口优于抽象类"><a href="#20-接口优于抽象类" class="headerlink" title="20. 接口优于抽象类"></a>20. 接口优于抽象类</h2><p>有两种方式可以定义一个多实现的接口：接口和抽象类；</p>
<p>因为Java只允许单继承，所以约束了抽象类作为类型定义的使用，但是接口可以被任意一个类所实现，不管类处于那个位置。</p>
<p>现有类可以很容易实现一个新接口，但是想要扩展一个相同的抽象类只能通过继承的方式，但是这种方式会带来较大的负面影响，强迫所有后代类都继承这个父类无论合不合适。</p>
<p>使用包装类可以安全的增强接口的功能，如果使用抽象类除了继承别无他法。</p>
<p>接口和抽象类可以搭配使用，接口中定义最基础的方法，抽象类实现这些基本的方法，其他子类可以选择是否继承这个抽象类，也可以选择实现最顶层的接口。这样更加灵活。例如Map.Entry的实现，因为接口中不能重写Object的equals和hashcode方法，所以这两种最基本的方法交给抽象类实现。</p>
<h2 id="21-为后代设计接口"><a href="#21-为后代设计接口" class="headerlink" title="21. 为后代设计接口"></a>21. 为后代设计接口</h2><p>Java8中添加了默认方法，目的是为了可以将方法加入现有的接口，但是在现有接口里添加的新方法是充满风险的。</p>
<p>在Java 8里，很多新的默认方法都被加入核心的集合接口里，这主要是为了促进lambda表达式的使用。</p>
<p>因为在接口中加入默认方法虽然可以通过编译但是在运行时可能会出错，这种事件不常有但是并不是不存在。因此应该避免在接口中添加新的default方法。如果必须要添加的话，需要考虑现有的实现类是否会收到影响。</p>
<h2 id="22-接口只用于定义类型"><a href="#22-接口只用于定义类型" class="headerlink" title="22. 接口只用于定义类型"></a>22. 接口只用于定义类型</h2><p>当类实现接口时，该接口作为实现类实例的引用。有种接口不符合这种目的，即常量接口，这种接口不包方法，只有静态final常量。</p>
<p>常量接口的缺点：</p>
<p>实现这个常量接口的实现类会泄露这些细节，这个类的子类的命名空间都会被接口的常量污染。</p>
<p>如果想要导出常量，有两种合适的方式。</p>
<ol>
<li>将这些常量添加到类或者相关的接口里。</li>
<li>新增枚举类型来导出这些常量。</li>
<li>这些常量放在不可初始化的工具类里面。</li>
<li>总之，接口应该只被用来定义类型。它们不能仅仅是用来导出常量。</li>
</ol>
<h2 id="23-类层次优于标签类"><a href="#23-类层次优于标签类" class="headerlink" title="23. 类层次优于标签类"></a>23. 类层次优于标签类</h2><p>标签类和类的层次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Shape</span> &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line">    <span class="comment">// Tag field - the shape of this figure</span></span><br><span class="line">    <span class="keyword">final</span> Shape shape;</span><br><span class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></span><br><span class="line">    <span class="type">double</span> length;</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    <span class="comment">// Constructor for circle</span></span><br><span class="line">    Figure(<span class="type">double</span> radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Constructor for rectangle</span></span><br><span class="line">    Figure(<span class="type">double</span> length, <span class="type">double</span> width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">            <span class="keyword">case</span> RECTANGLE:</span><br><span class="line">                <span class="keyword">return</span> length * width;</span><br><span class="line">            <span class="keyword">case</span> CIRCLE:</span><br><span class="line">                <span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Class hierarchy replacement for a tagged class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> radius;</span><br><span class="line">    Circle(<span class="type">double</span> radius) &#123; </span><br><span class="line">        <span class="built_in">this</span>.radius = radius; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> Math.PI * (radius * radius); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> width;</span><br><span class="line">    Rectangle(<span class="type">double</span> length, <span class="type">double</span> width) &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该避免标签类，标签类中有标签域，Switch语句，如果想要添加新的标签，必须在Switch语句中加case分支，否则会运行失败，标签类太过冗长并且不易阅读，出错率高。</p>
<p>我们可以将标签类转化为类层次的结构。</p>
<p>通过抽象出公有的标签值的方法。让每个子类继承抽象类，定义自己特有的数据域。</p>
<p>类层次的优点是，提高了代码的灵活性，清晰的展示了类之间的层次关系，并且可进行更好的变异检查。</p>
<h2 id="24-静态成员类优于非静态成员类"><a href="#24-静态成员类优于非静态成员类" class="headerlink" title="24. 静态成员类优于非静态成员类"></a>24. 静态成员类优于非静态成员类</h2><p>嵌套类是为了服务它所在的外围类。如果一个嵌套类还可以用于其他地方，那么应该单独放一个源文件里。</p>
<p>嵌套类的种类：静态成员类，非静态成员类，匿名内部类，局部类。</p>
<p>静态成员类：可以声明再其他类的内部，并且可以访问外围的所有成员变量。通常用法是和外围的类一块使用处理简单逻辑。</p>
<p>非静态成员类：不被static修饰的成员类，非静态实例被创建时就与外部类关联，并且关联后不可修改。常被用来定义适配器，例如Set,List中通过非静态成员类实现他们自己的迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; &#123;</span><br><span class="line">... <span class="comment">// Bulk of the class omitted</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyIterator</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果你声明了一个不需要访问外围实例的成员类，那你总是应该static修饰符加到声明里去</strong>，使得这个成员类是静态的。如果你不加这个修饰符，那么每个实例都将包含一个隐藏的外围实例的引用。更严重的是，当这个外围实例已经满足垃圾回收的条件时，非静态成员类实例会导致外围实例被保留。因此而导致的内存泄露是灾难性的。</p>
<p>匿名类：不是外围类的成员，没有名字，在代码任意一个表达式合法的地方，匿名类都可以使用。匿名类使用的限制：在声明之后无法再初始化，并且不能通过instanceof测试或者指定类名的操作，匿名类必须简短，否则会影响可读性。匿名类的另一个用法是实现静态工厂方法。lambda表达式出现后，创建小的函数对象通常首选lambda。</p>
<h2 id="25-限制源文件为单个顶级类"><a href="#25-限制源文件为单个顶级类" class="headerlink" title="25. 限制源文件为单个顶级类"></a>25. 限制源文件为单个顶级类</h2><p>永远不要将多个顶级类或接口放到一个源文件里。遵守这条规则就能保证在编译时不会遇到一个类有多个定义的情况。这又保证了编译产生的class文件和随之产生的程序行为不会依赖于传给编译器的源文件顺序。</p>
<p>程序的行为受传递给编译器的源文件顺序的影响，这是无法接受的。</p>
<p>解决方法那就是将这些顶级类分别写到各自的源文件里去。如果你尝试将多个顶级类放入同一个源文件，可以考虑使用静态成员类（条目）作为将不同类拆分为单独源文件的替代办法。</p>
<p>如果某些类是为其他类提供服务的，那么将这些类声明为静态私有成员类，这样可以减少类的可访问性，并且增强可阅读性。</p>
<h1 id="第四章-泛型"><a href="#第四章-泛型" class="headerlink" title="第四章 泛型"></a>第四章 泛型</h1><h2 id="26-不要使用原始类型"><a href="#26-不要使用原始类型" class="headerlink" title="26. 不要使用原始类型"></a>26. 不要使用原始类型</h2><p>泛型类型：接口和泛型类</p>
<p>泛型类型都定义了一组参数化的类型，如List<String> 表示元素是String类型的列表。</String></p>
<p>不应该使用原始类型，如List list = new ArrayList();</p>
<p>这样做如果加入的对象类型不一样虽，然可以通过编译，但是运行时会报错ClassCastException异常异常；应该使用参数化类型，这样在编译期间就可以发现错误，更加安全。</p>
<p>无限制通配符类型：Set&lt;?&gt;（读作，某些类型的集合），他和原始类型的区别是，通配符类型更加安全，当你讲任意非null得元素放入集合总，就会产生编译时错误。</p>
<p>原始类型被提供仅是为了兼容性以及能与引入泛型之前的遗留代码互用。</p>
<p>原始类型可以用在以下两种情况：</p>
<ol>
<li>List.class,Set.class,</li>
<li>if(o instanceof Set)</li>
</ol>
<h2 id="27-消除未检查警告"><a href="#27-消除未检查警告" class="headerlink" title="27. 消除未检查警告"></a>27. 消除未检查警告</h2><p>如果你无法消除某个警告，但是这个警告的代码是安全的，可以使用@SuppressWarnings(“unchecked”)注解来禁止这个警告。</p>
<p>SuppressWarnings注解可以声明在局部变量，方法，类上，但是应该尽可能的在小的作用域使用。每次使用这个注解应该加上注释，说明类型转换是安全的，可以帮别人理解这段代码。</p>
<p>每个未检查警告都表示可能在运行时出现ClassCastException异常，所以不要忽视他们。</p>
<h2 id="28-列表优先于数组"><a href="#28-列表优先于数组" class="headerlink" title="28. 列表优先于数组"></a>28. 列表优先于数组</h2><p>数组与列表的区别:</p>
<p>协变性：如果Sub是Super的一个子类型，那么数组类型Sub[]也是数组类型Super[]的子类型。</p>
<p>可具化：在运行时才知道并检查元素类型。</p>
<p>数组是协变的并可具化的；泛型是受约束并且可擦除的。因此，数组提供了运行时类型安全性但不保证编译时类型安全性，泛型则反过来。通常，数组和泛型不能很好混用.</p>
<p>数组在运行时才去检查元素的类型，如果将一个String加入Long的数组里，会抛出一个ArrayStoreException；泛型是在编译期间去检查的，运行时会擦除元素类型，泛型擦除使得泛型类型可以自由与从未使用过泛型的代码互相调用。因此使用泛型列表可以尽早发现错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  generic array creation is illegal - won&#x27;t compile</span></span><br><span class="line">List&lt;String&gt;[] stringLists = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">1</span>]; <span class="comment">// (1)</span></span><br><span class="line">List&lt;Integer&gt; intList = List.of(<span class="number">42</span>); <span class="comment">// (2)</span></span><br><span class="line">Object[] objects = stringLists; <span class="comment">// (3)</span></span><br><span class="line">objects[<span class="number">0</span>] = intList; <span class="comment">// (4)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// (5)</span></span><br></pre></td></tr></table></figure>

<p>为了尽可能避免出现泛型数组创建错误或者未检查异常，最好优先使用集合类型，它更安全。</p>
<h2 id="29-优先考虑使用泛型类"><a href="#29-优先考虑使用泛型类" class="headerlink" title="29. 优先考虑使用泛型类"></a>29. 优先考虑使用泛型类</h2><p>与强制转换类型相比，泛型更方便和安全，这通常意味着设计更加通用，客户端代码不用强制转换类型就可以使用泛型类的方法。</p>
<h2 id="30-优先考虑使用泛型方法"><a href="#30-优先考虑使用泛型方法" class="headerlink" title="30. 优先考虑使用泛型方法"></a>30. 优先考虑使用泛型方法</h2><p>Collections类的所有“算法”方法（如binarySearch方法和sort方法）都是泛型的。</p>
<p>常用泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// union s1 s2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> &#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型单例方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; UnaryOperator&lt;T&gt; <span class="title function_">identityFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (UnaryOperator&lt;T&gt;) IDENTITY_FN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归类型限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意能和自身比较的类型E</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; E <span class="title function_">max</span><span class="params">(Collection&lt;E&gt; c)</span>;</span><br></pre></td></tr></table></figure>

<p>应该保证你的方法不用客户端强转就能用，这意味着要将这些方法泛型化，你也应该将现有方法泛型化，让新用户用起来更简单，而且不用破坏现有客户端。</p>
<h2 id="31-使用有限制通配符来增加API灵活性"><a href="#31-使用有限制通配符来增加API灵活性" class="headerlink" title="31. 使用有限制通配符来增加API灵活性"></a>31. 使用有限制通配符来增加API灵活性</h2><p>通配符类型：&lt;? super E&gt;, &lt;? extend E&gt;</p>
<p>使用通配符的基本原则：PESC，一个参数化类型表示T类型的生产者，用&lt;? extend E&gt;；如果一个参数化类型代表一个T类型的消费者，则使用&lt;? super T&gt;。GET和PUT 原则。</p>
<p>通配符如果使用得当，对使用者来讲通配符的添加几乎是不可见的，通配符使得这些方法应该接收哪些参数，拒绝哪些参数。</p>
<p>返回类型不要用限制的通配符。因为这样强制客户端使用通配符类型。</p>
<h2 id="32-合理结合泛型和变长参数"><a href="#32-合理结合泛型和变长参数" class="headerlink" title="32. 合理结合泛型和变长参数"></a>32. 合理结合泛型和变长参数</h2><p>可变长参数的目的是为了允许客户端可以在方法里传入数量可变的参数，当你调用一个变长参数方法时，一个数组就会被创建，并用来存储这些参数，当变长参数是泛型类型或者参数化类型时，会得到编译器警告。</p>
<p>@SafeVarargs注解表示允许可变参数的方法使用泛型，并且禁止警告。除非确定了使用是安全的，否则不要使用这个注解。并且这个注解只对不重写的方法时合法的，Java8中仅仅对静态方法和final实例方法合法。</p>
<p>泛型可变参数是安全的情况：</p>
<ol>
<li>不在可变参数数组中存储数据</li>
<li>对外部代码不可见。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&lt;T&gt;List&lt;T&gt;pickTwo(Ta,Tb,Tc)&#123;</span><br><span class="line"><span class="keyword">switch</span>(rnd.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> List.of(a, b);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> List.of(a, c);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> List.of(b, c);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(); <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">  List&lt;String&gt; attributes = pickTwo(<span class="string">&quot;Good&quot;</span>, <span class="string">&quot;Fast&quot;</span>, <span class="string">&quot;Cheap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-考虑类型安全的异构容器"><a href="#33-考虑类型安全的异构容器" class="headerlink" title="33.考虑类型安全的异构容器"></a>33.考虑类型安全的异构容器</h2><p>泛型在容器中通常用法限制了每个容器类型参数的数量，可以使用Class对象作为类型安全异构容器的key，value是对应参数类型，以这种方式使用的Class对象被叫做类型令牌。</p>
<p>Favorites类称为类型安全的异构容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Favorites</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  	<span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> &#123;</span><br><span class="line">    	favorites.put(type, type.cast(instance));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">cast</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-枚举和注解"><a href="#第五章-枚举和注解" class="headerlink" title="第五章 枚举和注解"></a>第五章 枚举和注解</h1><h2 id="34-用枚举替换常量"><a href="#34-用枚举替换常量" class="headerlink" title="34.用枚举替换常量"></a>34.用枚举替换常量</h2><p>枚举类型（enum type）是指由一组固定的常量组成合法值的类型。在java 还没有引入枚举类型之前，通常使用int具名常量表示（如四季，月份，花色等）。</p>
<p>Java枚举本质上是int值。枚举是单例的泛型化，是受控制的，每个数据都是final的，枚举还允许添加任意的方法和域，并实现任意的接口，提供了Object的所有方法，实现了Comparable和Searializable，并针对枚举类型的可任意改变性设计了序列化方式。</p>
<p>枚举中的抽象方法必须被他所有常量中的具体方法覆盖。</p>
<p>什么时候可以使用枚举？</p>
<p>只要是在编译时已知的常量就可以使用枚举来代替。</p>
<p>枚举相比于int常量的优点：更好的可读性，安全性，更加强大，如果有多个枚举值同时有共享的行为，考虑使用策略枚举。</p>
<h2 id="35-使用实例域来替换序数"><a href="#35-使用实例域来替换序数" class="headerlink" title="35.使用实例域来替换序数"></a>35.使用实例域来替换序数</h2><p>每个枚举都有一个ordinal方法，他返回每个枚举在类型中的数字位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Ensemble</span> &#123;</span><br><span class="line">    SOLO, DUET, TRIO, QUARTET, QUINTET,</span><br><span class="line">    SEXTET, SEPTET, OCTET, NONET, DECTET;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfMusicians</span><span class="params">()</span> &#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果改变枚举变量中的顺序就会将这些常量重新排序，numberOfMusicians方法就会被破坏。</p>
<p>永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Ensemble</span> &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPTET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> numberOfMusicians;</span><br><span class="line">    Ensemble(<span class="type">int</span> size) &#123; <span class="built_in">this</span>.numberOfMusicians = size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfMusicians</span><span class="params">()</span> &#123; <span class="keyword">return</span> numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-使用EnumSet替换位域"><a href="#36-使用EnumSet替换位域" class="headerlink" title="36.使用EnumSet替换位域"></a>36.使用EnumSet替换位域</h2><p>位域：使用位运算讲几个常量合并到一个集合中，这个集合就是位域。</p>
<p>当打印输出位域时，很难理解这些常量的含义。所以使用EnumSet来代替。</p>
<p>EnumSet的优点：性能好（removeAll,retainAll方法都是利用位运算实现的），并且枚举更简洁表示含义更清晰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Style</span> &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line">    <span class="comment">// Any Set could be passed in, but EnumSet is clearly best</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyStyles</span><span class="params">(Set&lt;Style&gt; styles)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用EnumSet.of()</span></span><br><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure>

<h2 id="37-使用EnumMap替换序数索引"><a href="#37-使用EnumMap替换序数索引" class="headerlink" title="37.使用EnumMap替换序数索引"></a>37.使用EnumMap替换序数索引</h2><p>有时会用到Enum.ordinal方法，但是不推荐使用。</p>
<p>例如现在想要列出植物园中一年生，两年生，多年生植物。需要创建集合数组，每个生命周期的植物是一个集合。遍历整个花园的植物将对应生命周期的植物放在对应的集合中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle =</span><br><span class="line">    (Set&lt;Plant&gt;[]) <span class="keyword">new</span> <span class="title class_">Set</span>[Plant.LifeCycle.values().length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; plantsByLifeCycle.length; i++)</span><br><span class="line">    plantsByLifeCycle[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Plant p : garden)</span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);</span><br><span class="line"><span class="comment">// Print the results</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s: %s%n&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组不兼容泛型，也不知道数组中的索引代表什么，如果使用出错会抛出 ArrayIndexOutOfBoundsException 异常 。</p>
<p>可以使用EnumMap来代替数组的形式。Map的key是植物的生命周期枚举类型，value对应的是这种生命周期的所有植物。其实EnumMap内部就了这样的一个索引数组，只是隐藏操作数组的细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt;  plantsByLifeCycle =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Plant.LifeCycle.class);</span><br><span class="line"><span class="keyword">for</span> (Plant.LifeCycle lc : Plant.LifeCycle.values())</span><br><span class="line">    plantsByLifeCycle.put(lc, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (Plant p : garden)</span><br><span class="line">    plantsByLifeCycle.get(p.lifeCycle).add(p);</span><br></pre></td></tr></table></figure>

<p>总之使用EnumMap来代替索引数组，当出现对象之间的关系是多维的，使用EnumMap&lt;key1, EnumMap&lt;key,2 val&gt;&gt;</p>
<h2 id="38-使用接口来模仿可扩展的枚举"><a href="#38-使用接口来模仿可扩展的枚举" class="headerlink" title="38.使用接口来模仿可扩展的枚举"></a>38.使用接口来模仿可扩展的枚举</h2><p>操作码用例可以使用可伸缩性的枚举类型实现。操作码的元素表示在某种机器上的操作。</p>
<p>定义操作接口，枚举实现这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Emulated extensible enum using an interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">BasicOperation</span> <span class="keyword">implements</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    PLUS(<span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">        BasicOperation(String symbol) &#123;</span><br><span class="line">        <span class="built_in">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然枚举不能多实现但是，接口支持多实现，可以定义多个枚举实现这个接口。并用新的实现类代替基本类型。</p>
<p>用接口实现可伸缩枚举的不足之处是：枚举不能继承另一个枚举。如果代码不依赖任何枚举的状态，就可以在接口中添加默认实现。java.nio.file.LinkOption 枚举类型实现了 CopyOption 和 OpenOption 接口。</p>
<h2 id="39-注解优先于命名模式"><a href="#39-注解优先于命名模式" class="headerlink" title="39.注解优先于命名模式"></a>39.注解优先于命名模式</h2><p>命名模式：表名一些程序需要通过某种工具或者框架进行特殊处理。</p>
<p>缺点：</p>
<ol>
<li>如果命名出现错误，就不会执行但是也不会报错。</li>
<li>不能确保他们只用在相应的程序元素上。比如有个名字叫TestSafetyMechanisms的类，想要测试这个类中的所有方法，但是Junit3不会执行，因为这个类中的方法名不是test开头的。</li>
<li>命名模式没有提供将参数值将程序元素相关联的方法。</li>
</ol>
<p>JUnit 从第 4 版开始采用@Test注解，解决了以上问题。Test注解只在方法上起作用，不能被用在类上或者其他元素上，否则编译不过。因为Test注解没有参数所以叫做标记注解。注解永远不会改变被注解代码的语义，但是使它可以通过工具进行特殊的处理。</p>
<p>注解的处理是使用反射执行标记了注解的方法，在执行过程中捕获异常并打印日志，还可以获取到注解上的参数，并校验参数类型。注解中的数组参数语法很灵活，指定多元素数组使用{}包裹，并用逗号分隔开。</p>
<h2 id="40-坚持使用Overide注解"><a href="#40-坚持使用Overide注解" class="headerlink" title="40. 坚持使用Overide注解"></a>40. 坚持使用Overide注解</h2><p>@Override注解用户方法声明，表示被注解的方法会覆盖父类的方法，如果坚持使用这个注解，可以防止一大类的非法错误。</p>
<p>比如Bigram类本身想要重写父类Object的hashCode和toString方法，但是因为类型错误，没能覆盖而是重载了equals方法。并且因为没有标注@Overide所以在编译的时候没能发现这个错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Can you spot the bug?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bigram</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> second;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bigram</span><span class="params">(<span class="type">char</span> first, <span class="type">char</span> second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数类型应该是Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Bigram b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.first == first &amp;&amp; b.second == second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * first + second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;Bigram&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ch++)</span><br><span class="line">                s.add(<span class="keyword">new</span> <span class="title class_">Bigram</span>(ch, ch));</span><br><span class="line">        System.out.println(s.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-标记接口定义接口类型"><a href="#41-标记接口定义接口类型" class="headerlink" title="41. 标记接口定义接口类型"></a>41. 标记接口定义接口类型</h2><p>标记接口：接口中不包含任何方法声明。例如Serilizable接口。</p>
<p>标记接口比标记注解的两个优点：</p>
<ol>
<li>标记接口定义的类型是可被实例类实现的，但是注解不行。标记接口类型允许在编译时捕获错误但是注释只能在运行时捕获错误。</li>
<li>可以被更加精确的锁定，如果注解类型使用ElementType.TYPE声明，他就表示可以被应用到任何类或者接口。</li>
</ol>
<p>什么时候使用标记注解？</p>
<p>如果标记的不是类和接口，就使用注解。如果标记要应用到类和接口这时候考虑我是否想要编写一个或者多个具有该标记的方法呢？如果是就优先使用标记接口。</p>
<h1 id="第六章-Lambda和Stream"><a href="#第六章-Lambda和Stream" class="headerlink" title="第六章 Lambda和Stream"></a>第六章 Lambda和Stream</h1><h2 id="42-lambda表达式优先于匿名类"><a href="#42-lambda表达式优先于匿名类" class="headerlink" title="42. lambda表达式优先于匿名类"></a>42. lambda表达式优先于匿名类</h2><p>在Java8之前创建函数对象的主要方式是匿名类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(words, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s1.length(), s2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>匿名类适用于需要函数对象的经典面向对象设计模式，尤其是策略模式，比较器接口是排序的抽象策略。</p>
<p>在Java8中引入了函数式接口，允许使用lambda表达式创建这些接口实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(words,</span><br><span class="line">        (s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure>

<p>编译器从上下文中根据类型推断推导出这些参数的类型，在某些时候，需要指定参数类型，否则编译器无法确定这些参数类型。</p>
<p>与其他方法和类不同，lambda没有名称和文档；如果计算不是自解释的，或者超过几行，则不要将其放入lambda表达式中，如果lambda表达式太长会影响可读性。</p>
<p>除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。</p>
<h2 id="43-方法引用优于lambda表达式"><a href="#43-方法引用优于lambda表达式" class="headerlink" title="43. 方法引用优于lambda表达式"></a>43. 方法引用优于lambda表达式</h2><p>lambda优于匿名类的主要优点是更加简洁，Java提供了生成函数对象的方法比lambda还要简洁。两者在选用过程中哪个简洁使用哪个。</p>
<table>
<thead>
<tr>
<th><strong>Method Ref Type</strong></th>
<th><strong>Example</strong></th>
<th><strong>Lambda Equivalent</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Static</td>
<td>Integer::parseInt</td>
<td>str -&gt; Integer.parseInt(str)</td>
</tr>
<tr>
<td>Bound</td>
<td>Integer::parseIntr</td>
<td>Instant then = Instant.now(); t -&gt; then.isAfter(t)</td>
</tr>
<tr>
<td>Unbound</td>
<td>String::toLowerCase</td>
<td>str -&gt; str.toLowerCase()</td>
</tr>
<tr>
<td>Class Constructor</td>
<td>TreeMap&lt;K, V&gt;::new</td>
<td>() -&gt; new TreeMap&lt;K, V&gt;</td>
</tr>
<tr>
<td>Array Constructor</td>
<td>int[]::new</td>
<td>len -&gt; new int[len]</td>
</tr>
</tbody></table>
<h2 id="44-优先使用标准的函数式接口"><a href="#44-优先使用标准的函数式接口" class="headerlink" title="44. 优先使用标准的函数式接口"></a>44. 优先使用标准的函数式接口</h2><p>6哥基本的函数式接口</p>
<table>
<thead>
<tr>
<th><strong>Interface</strong></th>
<th><strong>Function Signature</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td>UnaryOperator</td>
<td>T apply(T t)</td>
<td>String::toLowerCase</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>T apply(T t1, T t2)</td>
<td>BigInteger::add</td>
</tr>
<tr>
<td>Predicate</td>
<td>boolean test(T t)</td>
<td>Collection::isEmpty</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>R apply(T t)</td>
<td>Arrays::asList</td>
</tr>
<tr>
<td>Supplier</td>
<td>T get()</td>
<td>Instant::now</td>
</tr>
<tr>
<td>Consumer</td>
<td>void accept(T t)</td>
<td>System.out::println</td>
</tr>
</tbody></table>
<p>如果基本的函数式接口可以满足你的要求，那应该优先使用它而不是新建功能接口。</p>
<p>Function接口有9个变体，如果源类型和结果类型都是基本类型则使用源类型作为前缀的Function，例如LongToIntFunction，如果源类型是基本类型但是结果类型是引用类型，则使用ToObj前缀的Function，如DoubleToObjFunction。</p>
<p>什么时候考虑编写新的功能接口（Comparator）而不是使用标准接口？</p>
<ul>
<li>该接口将被普遍使用</li>
<li>具有相关的约定</li>
<li>受益于自定义的默认方法</li>
</ul>
<p>其他大部分情况使用Function提供的标准接口。</p>
<h2 id="45-明智地使用streams"><a href="#45-明智地使用streams" class="headerlink" title="45. 明智地使用streams"></a>45. 明智地使用streams</h2><p>流：表示有限或无限的数据元素序列；</p>
<p>流管道：表示对这些元素多阶段的结算</p>
<p>流管道的计算是惰性的，直到调用teminal操作时才开始计算，并且对完成terminal操作不需要的数据元素不会计算。默认情况下流管道按照顺序运行。</p>
<p>流API非常通用，实际上任何计算都可以使用流执行，如果使用得当可以使程序更加简短清晰。使用不当会导致程序难以读取和维护。</p>
<p>lambda表达式的餐胡命名对于流管道的可读性至关重要。</p>
<p>在流管道中使用helper方法比在循环中重要。</p>
<p>在lambda表达式中，只能读取final的变量，不能修改任何局部变量。</p>
<p>flatMap：将流扁平化。将Stream中的每个元素映射到新的流然后关联起来。</p>
<h2 id="46-优先使用Stream无副作用的函数"><a href="#46-优先使用Stream无副作用的函数" class="headerlink" title="46. 优先使用Stream无副作用的函数"></a>46. 优先使用Stream无副作用的函数</h2><p>流管道编程的本质是无副作用的对象，这适用于传递给流和相关对象。foreach方法仅用于输出计算结果，还不适用于执行计算。收集器常见的有，toList，toSet，toMap，groupingBy和join。</p>
<p>养成将collecto()方法中放静态方法的习惯，因为这样可读性更高。</p>
<p>toMap操作如果一个key对应了多个流元素就会抛出IllegalStateException异常来终止。这时候使用三个参数的toMap()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toMap(keyMapper, valueMapper, (v1, v2) -&gt; v2)</span><br></pre></td></tr></table></figure>

<p>当发生冲突，执行第三个参数设置的last-write-wins策略。</p>
<h2 id="47-Stream优先使用Collection作为返回类型"><a href="#47-Stream优先使用Collection作为返回类型" class="headerlink" title="47. Stream优先使用Collection作为返回类型"></a>47. Stream优先使用Collection作为返回类型</h2><p>如果编写一个的方法知道会在流管道中使用，可以返回Stream，类似的如果仅用于遍历序列则可以返回Iterable接口。</p>
<p>Collection是Iterable的子类型，因此可迭代并支持Stream，因此，Collection或者他的子类是返回方法的最佳返回类型。</p>
<p>如果返回的数据量小并且可以放入内存中，那么最好返回标准的集合。如果数据太多，不要作为集合返回。</p>
<h2 id="48-谨慎使用Stream并行"><a href="#48-谨慎使用Stream并行" class="headerlink" title="48. 谨慎使用Stream并行"></a>48. 谨慎使用Stream并行</h2><p>如果源来自 Stream.iterate，或者使用中间操作限制，并行化管道也不太可能提高其性能。所以不要不加选择的使用并行流导致性能灾难。</p>
<p>并行性的性能增益最好是在 ArrayList，HashMap，HashSet 和 ConcurrentHashMap 实例上；int 数组；和 long 数组。因为它们都可以准确且分成任何所需大小的子范围。</p>
<p>这使得在并行线程之间划分工作变得容易。</p>
<p>并行流不仅有可能会导致性能上的问题，还可能导致不正确的结果和不可预测的行为（安全失败）。使用.map,filter其他不规范的功能丰富都可能导致并行的安全出问题。</p>
<p>通常所有的并行流管道都在公共fork-join线程池中运行。单个行为不当的管道流会影响系统中其他不想关的部分。</p>
<p>总之除非使用并行流之后得到的结果是正确的并且相比之前对性能上有预期的提升，否则不应该尝试使用并行的管道流。</p>
<h1 id="第七章-方法"><a href="#第七章-方法" class="headerlink" title="第七章 方法"></a>第七章 方法</h1><h2 id="49-校验参数有效性"><a href="#49-校验参数有效性" class="headerlink" title="49. 校验参数有效性"></a>49. 校验参数有效性</h2><p>大多数方法包括构造方法对于参数值都有某些限制，例如引用类型必须不能为null，数组下标必须大于等于0等。校验参数如果出现错误抛出一个参数校验异常，不在进行后续的操作。</p>
<p>Java7中添加的 Objects.requireNonNull(Object obj, “errorMessage”) 可以校验对象引用不为null，比较灵活。</p>
<p>Java 9 中，范围检查工具被添加到 java.util.Objects 中。该工具由三个方法组成：checkFromIndexSize，checkFromToIndex 和 checkIndex。此工具不如空检查方法灵活。它不允许你自定义异常的详细消息，它仅用于列表和数组索引。</p>
<p>每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来校验这些限制。养成这样的习惯是非常重要的。</p>
<h2 id="50-必要时进行保护性拷贝"><a href="#50-必要时进行保护性拷贝" class="headerlink" title="50. 必要时进行保护性拷贝"></a>50. 必要时进行保护性拷贝</h2><p>对于构造器中的每个参数进行保护性拷贝是必要的的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Repaired constructor - makes defensive copies of parameters</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Period</span><span class="params">(Date start, Date end)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.start = <span class="keyword">new</span> <span class="title class_">Date</span>(start.getTime());</span><br><span class="line">    <span class="built_in">this</span>.end = <span class="keyword">new</span> <span class="title class_">Date</span>(end.getTime());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.start.compareTo(<span class="built_in">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="built_in">this</span>.start + <span class="string">&quot; after &quot;</span> + <span class="built_in">this</span>.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。</p>
<p>例如你正在使用客户端提供的对象引用作为内部Set实例的元素，或者作为内部Map的Key，就应该意识到如果这个对象在插入之后被修改，Map中的约束条件就会被破坏，因此需要对这个对象做保护性拷贝。</p>
<p>保护性拷贝可能会带来性能损失但是也不一定。如果一个类信任他的调用者不会修改内部的组件，可能因为类以及客户端都在同一个包里，那么不进行保护性拷贝也是可以的。</p>
<p>即使不在同一个package下，也并不总是在可变参数整合到对象之前对他进行保护拷贝。</p>
<p>简而言之，如果类具有从客户端得到或者返回给客户端的可变组件，类就必须设计保护性拷贝，如果拷贝的成本收到限制，并且类信任客户端不会错误修改返回的组件，就可以在文档中知名客户端的职责是不得修改收到影响的组件以此代替保护性拷贝。</p>
<h2 id="51-谨慎设计方法签名"><a href="#51-谨慎设计方法签名" class="headerlink" title="51. 谨慎设计方法签名"></a>51. 谨慎设计方法签名</h2><ul>
<li><p>谨慎选择方法名称：方法名称首要目标是易于理解第二个目标是广泛认可的命名。</p>
</li>
<li><p>不要过于追求提供遍历的方法</p>
</li>
<li><p>避免过长的参数列表。参数个数应该小于等于4。</p>
<ul>
<li>缩短参数列表的方法<ul>
<li>将方法拆分成多个方法</li>
<li>创建参数类型保存参数的分组，一般是静态成员类</li>
<li>构建参数对象时使用建造者模式</li>
</ul>
</li>
</ul>
</li>
<li><p>对于参数类型优先使用接口而不是类</p>
</li>
<li><p>对于Boolean类型的参数优先使用枚举类型</p>
</li>
</ul>
<h2 id="52-慎用重载"><a href="#52-慎用重载" class="headerlink" title="52. 慎用重载"></a>52. 慎用重载</h2><p>当一个方法被重载后，调用哪个方法是在编译时决定的。</p>
<p>对于选择哪个重载方法是在编译期决定的，选择被覆盖的方法是在运行时进行的，选择的依据是被调用方法的对象的运行时类型。</p>
<p>覆盖机制满足了人们对于方法调用行为的期望，重载不及期望，因此避免乱用重载机制。</p>
<p>避免重载的方法：不要导出两个具有相同参数数目的重载方法。</p>
<p>一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。当正在改造一个现有的类来实现新的接口就应该保证，当传递同样的参数时，所有的虫子啊方法的行为必须一致，如果不能保证这点，开发者就会不理解为什么不能正常工作。</p>
<h2 id="53-慎用可变参数"><a href="#53-慎用可变参数" class="headerlink" title="53. 慎用可变参数"></a>53. 慎用可变参数</h2><p>可变参数可以接受0个或者多个指定类型的参数，可变参数通过创建一个数组，数组的大小是参数的数量，然后将参数值传递到数组中，最后将数组传给方法。</p>
<p>当需要让一个方法带有不定数量的参数时，可变参数非常有效，在性能要求高的情况下要小心使用可变参数，因为每次调用可变参数方法就会为数组分配内存和初始化。</p>
<h2 id="54-返回空集合或者是数组而不是null"><a href="#54-返回空集合或者是数组而不是null" class="headerlink" title="54. 返回空集合或者是数组而不是null"></a>54. 返回空集合或者是数组而不是null</h2><p>当使用null代替空集合或者数组的返回值的时候就容易出错，因为客户端调用者会忘记处理这个null，从而抛出NPE，返回null容易使你的方法难以维护容易出错，而且没有什么性能上的优势。</p>
<h2 id="55-谨慎返回Optionals"><a href="#55-谨慎返回Optionals" class="headerlink" title="55. 谨慎返回Optionals"></a>55. 谨慎返回Optionals</h2><p>在Java8之前，当有遇到无法返回值的方法时，可以抛出异常或者返回null，但是这两种都不算完美，异常需要额外的代码来处理，需要调用者try-cache处理异常；如果返回null容易出现NullPointException。</p>
<p>Optional类在Java8版本中表示可以持有单个非空引用或者什么都没有的不可变容器。因此当无法给方法返回返回值的时候可以返回一个Optional。</p>
<p>optional可以使用empty()和of(T value)方法创建Optional实例，但是of方法中的入参不能是null，否则会抛出NullPointException。</p>
<p>并不是所有的返回类型都能受益于optional的返回类型。容器类型，包括Collection，map，stream，数组，以及optional都不应该再用optional进行包装了。你应该放回一个空的List，而不是空的Optional<List>。</List></p>
<p>不应该把基本封装类型的Optional作为返回值，应该使用对应的OptionalInt/OptionalLong/OptionalDouble</p>
<p>返回optional的时候，会有性能问题，对于性能要求严格的方法，可能还是返回null或者抛出异常要更好一些。</p>
<h2 id="56-为所有导出的API元素编写文档注释"><a href="#56-为所有导出的API元素编写文档注释" class="headerlink" title="56. 为所有导出的API元素编写文档注释"></a>56. 为所有导出的API元素编写文档注释</h2><p>对API进行合适的文档注释，必须在每个导出的类，接口，构造器，方法，属性字段声明前写文档注释。如果这个类是可序列化的也应该为它的序列化形式编写doc.</p>
<p>为方法编写文档注释时，必须说明这个方法做了什么，而不是具体的实现细节。通过@throw标签抛出方法中uncheckedException。其中@param也为参数设置了前提条件以及含义。@return标签表示该方法的返回值类型以及含义。</p>
<blockquote>
<p>文档注释是将API文档化的最有效的方法。对于所有导出的API元素，应该强制使用文档注释。采用一贯的风格来遵守标准的约定。记住，在文档注释中可以出现任何的HTML标签，但是那些HTML元字符必须进行转义。</p>
</blockquote>
<h1 id="第八章-通用设计"><a href="#第八章-通用设计" class="headerlink" title="第八章 通用设计"></a>第八章 通用设计</h1><h2 id="57-局部变量作用域最小化"><a href="#57-局部变量作用域最小化" class="headerlink" title="57. 局部变量作用域最小化"></a>57. 局部变量作用域最小化</h2><p>将局部变量作用域最小化的有效方法是在第一次使用这个变量时进行声明。如果在使用之前声明，会比较混乱。</p>
<p>如果一个变量在使用方法的外面进行了声明，当程序退出这个块的时候，这个变量还是可见的，如果这个变量在目标方法外使用之前对变量进行了更改就会照成意外的错误。</p>
<p>每个变量的声明都应该立即初始化，如果不确定是否初始化，应该延迟声明直到可以初始化为止。try-cache语句是个例外，如果变量需要在try代码块之外使用，就必须在方法块之前声明。</p>
<p>当循环变量在循环结束之后不再使用的时候，使用for循环优于while循环。</p>
<h2 id="58-for-each优于传统for循环"><a href="#58-for-each优于传统for循环" class="headerlink" title="58. for-each优于传统for循环"></a>58. for-each优于传统for循环</h2><p>增强for循环通过隐藏Iterator和索引变量解决了混乱和可能出现的问题。更加灵活简洁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The preferred idiom for iterating over collections and arrays</span></span><br><span class="line">   <span class="keyword">for</span> (Element e : elements) &#123;</span><br><span class="line">       ... <span class="comment">// Do something with e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强for循环没有什么性能损失，对数组集合都一样。</p>
<p>有三种情况下不能使用增强for循环</p>
<ul>
<li>破坏性过滤：如果你想遍历一个集合，然后删除指定的元素，必须使用iterator，调用remove方法。或者使用Collection的removeIf方法。</li>
<li>转换：如果想要遍历集合或者数组替换部分元素的值，必须使用迭代器或者数组索引。</li>
<li>并行遍历要是用索引变量或者迭代器</li>
</ul>
<h2 id="59-了解和使用类库"><a href="#59-了解和使用类库" class="headerlink" title="59. 了解和使用类库"></a>59. 了解和使用类库</h2><p>使用标准类库，可以充分利用编写类库的专家知识；</p>
<p>不需要浪费时间来为一个和工作关系不大的问题编写特别的解决方法，应该关注在应用程序上而不是底层实现。</p>
<p>当你的需求比较特殊时，类库机制可能不会满足你的需求，这时候需要找第三方类库中看是否有合适的实现，比如Google的guava。否则的话就需要自己实现了。</p>
<h2 id="60-精确值避免使用float和double"><a href="#60-精确值避免使用float和double" class="headerlink" title="60. 精确值避免使用float和double"></a>60. 精确值避免使用float和double</h2><p>对于任何需要精确计算的结果，都不要使用float和double，使用BigDecimal来替换他，BigDecimal还有一个优点是，可以控制舍入的位数。</p>
<h2 id="61-基本类型优于封装类型"><a href="#61-基本类型优于封装类型" class="headerlink" title="61. 基本类型优于封装类型"></a>61. 基本类型优于封装类型</h2><p>基本类型和封装类型的三个不同点。</p>
<ol>
<li>基本类型比封装类型在时间和空间上更加节省</li>
<li>基本类型只有值，封装类型还有可能为null</li>
<li>封装类型除值的性质之外还有其他属性。虽然两个封装类型的值是一样的但是有可能是不同的对象。</li>
</ol>
<p>当面临选择的时候优先使用基本类型，因为基本类型简单且快速，当封装类型和基本类型混合计算的时候，会做拆箱的动作，这时有可能会抛出NullPointException。</p>
<h2 id="62-其他类型合适时避免使用String"><a href="#62-其他类型合适时避免使用String" class="headerlink" title="62. 其他类型合适时避免使用String"></a>62. 其他类型合适时避免使用String</h2><p>String是专门用来表示文本的，如果是数值类型不应该使用String表示。如果是是否选择问题应该转换成枚举或者boolean类型。</p>
<p>如果存在更加合适数据类型（或者可以编写一个）的时候，要避免习惯地使用字符串来表示对象。使用不当的话，String比其他类型会更加笨重、不灵活、慢、容易出错。很容易被错用成String的类型主要有基本类型、枚举类型和聚合类型。</p>
<h2 id="63-了解字符串拼接的性能"><a href="#63-了解字符串拼接的性能" class="headerlink" title="63. 了解字符串拼接的性能"></a>63. 了解字符串拼接的性能</h2><p>大规模字符串连接时，使用+操作符，需要的时间是N^2，因为字符串是不可变的，当两个字符串进行连接的时候，，需要将他们的内容都复制一下。</p>
<p>因此在字符串拼接的时候为了打到可接受的性能，可以使用StringBuilder代替String来保存构造过程中的声明。</p>
<h2 id="64-使用接口引用对象"><a href="#64-使用接口引用对象" class="headerlink" title="64. 使用接口引用对象"></a>64. 使用接口引用对象</h2><p>如果你养成了使用接口作为类型的习惯，程序就会变得非常灵活。无论是返回类型，参数类型，变量等都应该使用接口类型声明。</p>
<p>当没有合适的接口存在的时候，使用类而不是接口来引用对象，是非常合适的。比如String和BigInteger，通常返回是final的，也很少有对应的接口。</p>
<p>总的来讲，如果一个对象有合适的接口，使用接口来引用对象；如果没有合适的接口，就选择能够提供需要功能的最小的类。</p>
<h2 id="65-j接口优于反射"><a href="#65-j接口优于反射" class="headerlink" title="65. j接口优于反射"></a>65. j接口优于反射</h2><h2 id="66-谨慎的使用本地方法"><a href="#66-谨慎的使用本地方法" class="headerlink" title="66. 谨慎的使用本地方法"></a>66. 谨慎的使用本地方法</h2><h2 id="67-谨慎优化"><a href="#67-谨慎优化" class="headerlink" title="67. 谨慎优化"></a>67. 谨慎优化</h2><h2 id="68-遵守命名规范"><a href="#68-遵守命名规范" class="headerlink" title="68. 遵守命名规范"></a>68. 遵守命名规范</h2><h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章 异常"></a>第九章 异常</h1><h1 id="第十章-并发"><a href="#第十章-并发" class="headerlink" title="第十章 并发"></a>第十章 并发</h1><h1 id="第十一章-序列化"><a href="#第十一章-序列化" class="headerlink" title="第十一章 序列化"></a>第十一章 序列化</h1><p>在线阅读地址：<a href="https://jiapengcai.gitbooks.io/effective-java/content/chapter1/di-1-tiao-ff1a-kao-lv-yong-jing-tai-fang-fa-er-bu-shi-gou-zao-qi.html">Effective Java</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/posts/f0675471/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>netty</title>
    <url>/posts/ddaa8ce6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/posts/a477be03/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>redis</title>
    <url>/posts/7b25d017/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/posts/5bbc7517/</url>
    <content><![CDATA[<p>kafka主要应用场景以及相关问题</p>
<span id="more"></span>

<h2 id="kafka主要的应用场景"><a href="#kafka主要的应用场景" class="headerlink" title="kafka主要的应用场景"></a>kafka主要的应用场景</h2><p>kafka是一个分布式流式处理平台。提供消息持久化机制。与其他消息队列相比，kafka的性能更好（批处理和异步，每秒可以处理千万级别的消息），生态系统比较完善（大数据领域和流式计算）。</p>
<p>应用场景</p>
<ol>
<li>消息队列：建立实时数据管道，可在系统或者应用程序之间传递数据。特点（异步，解耦，流控）</li>
<li>数据处理：构建实时的数据处理程序处理数据流</li>
</ol>
<h2 id="kafka的消息模型"><a href="#kafka的消息模型" class="headerlink" title="kafka的消息模型"></a>kafka的消息模型</h2><p>发布订阅模型，producer发布一条消息，通过topic传递给所有的订阅者。</p>
<h2 id="kafka组件的基本概念"><a href="#kafka组件的基本概念" class="headerlink" title="kafka组件的基本概念"></a>kafka组件的基本概念</h2><ul>
<li>producer：消息发生产发送者</li>
<li>consumer：消费者，负责从kafka接收消息并消费</li>
<li>broker：代理服务器，是kafka集群中的一个节点，每个broker可以存储多个topic和paration的数据，并且和其他broker协调工作。</li>
<li>topic：主题，是一类消息的集合，每个topic可以被分为多个分区，每个分区可以存储一定数量的消息。</li>
<li>paration：分区，每个paration可以有多个副本，以提高可用性和容错性。</li>
<li>consumer group：消费者组，通过group id区分，每个组相互独立。一个消费者组可以消费多个paration，实现高吞吐。</li>
<li>replication：副本，同一条消息被拷贝到多台机器提供数据冗余，副本分为leader replication 和follower replication。每个paration可配置多个副本实现高可用。</li>
<li>offset：表示分区中每条消息的位置信息，是一个单调递增的值。叫做偏移量或者位移，一旦被写入到分区日志，将不会被修改。</li>
</ul>
<h2 id="多副本机制有什么好处"><a href="#多副本机制有什么好处" class="headerlink" title="多副本机制有什么好处"></a>多副本机制有什么好处</h2><p>kafka中一个topic可以对应多个paration，各个paration可以分布在不同的broker上，这样可以提供更好的并发能力。因为paration可以指定多个副本，这就提高了消息存储的安全性和容灾能力，不过也增加了所需要的存储空间。</p>
<h2 id="leader副本和follower副本的区别"><a href="#leader副本和follower副本的区别" class="headerlink" title="leader副本和follower副本的区别"></a>leader副本和follower副本的区别</h2><p>只有leader副本才能对外提供读写服务，相应client端的请求。follower副本只是采用pull的方式被动同步leader副本中的数据，并且在leader副本宕机时，随时代替leader副本。</p>
<p>在kafka2.4版本开始，社区通过引入新的broker端参数，允许follower副本有限度的提供服务。</p>
<p>通常情况下，很多因素可能会造成leader和follower之间的不同步（程序异常，broker，网络问题等），如果长时间不通过就需要深入排查了。</p>
<p>注意：之前确保一致性的主要手段是高水位机制（HW），但高水位值无法保证Leader连续变更场景下的数据一致性，因此，社区引入了Leader Epoch机制，来修复高水位值的弊端。</p>
<h2 id="zookeeper在kafka中的作用是什么"><a href="#zookeeper在kafka中的作用是什么" class="headerlink" title="zookeeper在kafka中的作用是什么"></a>zookeeper在kafka中的作用是什么</h2><ul>
<li>提供元数据管理能力。</li>
<li>成员管理是指broker节点的注册，注销，属性变更等。</li>
<li>controller选举是指选举集群controller，而其他管理类任务包括但不限于topic的删除，参数配置等。</li>
</ul>
<p>kafka2.8.x以后剔除掉了对zookeeper的依赖，使用@metadata topic用来管理元数据信息。kraft里面存储新的配置文件。</p>
<p>去掉zookeeper之后的优点</p>
<ul>
<li>部署更简单</li>
<li>性能更好</li>
<li>监控更便捷</li>
</ul>
<h2 id="kafka如何保证消息的消费顺序是有序的"><a href="#kafka如何保证消息的消费顺序是有序的" class="headerlink" title="kafka如何保证消息的消费顺序是有序的"></a>kafka如何保证消息的消费顺序是有序的</h2><p>对于kafka，producer可以在写数据的时候指定一个key，比如userId, orderId，遇到相同id的数据会被分发到同一个paration，消费者从paration中取出来的数据也是有序的。</p>
<p>对于多线程消费时，如何保证有序？</p>
<p>预先设置N个队列，拥有相同key的数据放到同一个内存队列中，然后开启N个线程分别去消费对应的队列。</p>
<h2 id="kafka如何保证发送的消息不丢失"><a href="#kafka如何保证发送的消息不丢失" class="headerlink" title="kafka如何保证发送的消息不丢失"></a>kafka如何保证发送的消息不丢失</h2><p>broker丢消息</p>
<ul>
<li><p><strong>设置 replication.factor &gt;= 3</strong></p>
</li>
<li><p><strong>设置request.require.acks=-1</strong>（默认是1，等ISR列表里面的所有follower paration 都写成功才返回给producer写成功）</p>
</li>
<li><p><strong>设置min.insync.replicas &gt;= 2</strong> （默认值是1，表示ISR列表里面至少有1个副本）</p>
</li>
<li><p><strong>设置unclean.leader.election.enable=false</strong>，这是Broker端的参数，如果一个Broker落后消息相比leader太多，就禁止让他成为新leader。</p>
</li>
</ul>
<p>producer端丢消息</p>
<ul>
<li>**使用producer.send(msg,callback)**，回调函数判断是否发送成功，如果因为网络或者其他原因发送失败，一般会进行重试，重试次数一般是3，并设置重试时间间隔，间隔太小重试效果不明显</li>
</ul>
<p>consumer端丢失消息</p>
<ul>
<li><strong>设置enable.auto.commit=false</strong>，默认情况下consumer拉取到分区的某个消息之后会自动提交offset，如果在消费前consumer挂掉会导致丢消息，所以可以设置成手动提交。（手动提交要注意保证消费端的幂等性）</li>
</ul>
<h2 id="kafka如何保证消息不重复消费"><a href="#kafka如何保证消息不重复消费" class="headerlink" title="kafka如何保证消息不重复消费"></a>kafka如何保证消息不重复消费</h2><p>生产者：</p>
<ul>
<li>pid：producerID，每个新的producer在初始化的时候会被分配一个唯一的pid</li>
<li>序列号：对于每个PID该producer发送的每个paration都对应一个从0开始单调递增的sequence number。</li>
</ul>
<p>broker在缓存中保存了序列号，对于接收的每个消息，如果序号大于broker缓存中的序号则接收否则就丢弃，这样可以保证单个producer对于同一个paration的幂等。</p>
<p>消费者：</p>
<ul>
<li>在数据库种根据主键或者唯一约束进行去重过滤。</li>
<li>或者通过redis去重</li>
<li>通过producer发送消息带上全局业务唯一key</li>
</ul>
<p>kafka默认模式是at least once，但是这种模式可能产生重复的消费问题，所以业务逻辑必须做幂等处理。</p>
<h2 id="kafka为什么那么快"><a href="#kafka为什么那么快" class="headerlink" title="kafka为什么那么快"></a>kafka为什么那么快</h2><ul>
<li>使用cache pageCache缓存</li>
<li>顺序写入：磁盘的顺序写入比随机写入内存更快</li>
<li>零拷贝：减少拷贝次数</li>
<li>批处理消息：合并小的请求，然后以流的方式进行交互，直到网络上限。</li>
<li>pull模式：使用拉去模式进行消息的获取消费。</li>
</ul>
<h2 id="producer发送数据，ack设置的含义"><a href="#producer发送数据，ack设置的含义" class="headerlink" title="producer发送数据，ack设置的含义"></a>producer发送数据，ack设置的含义</h2><p>request.required.acks 有三个值分别是0 1 -1</p>
<ul>
<li>0 ：producer不会等待broker的ack，延迟最低但是会丢数据</li>
<li>1：发一条消息，当leader paration写入成功以后才算写入成功，不过这种方式也有丢数据的可能。</li>
<li>-1：当ISR列表里面的所有副本写成功之后才返回ack</li>
</ul>
<h2 id="kafka中的ISR，AR表示什么"><a href="#kafka中的ISR，AR表示什么" class="headerlink" title="kafka中的ISR，AR表示什么"></a>kafka中的ISR，AR表示什么</h2><p>ISR（in-sync-replicas）,副本同步集合，在这个集合中的follower会和leader副本进行同步，不在的不会进行同步。这是一个动态调整的集合。</p>
<p>AR：表示所有副本，包含OSR和ISR。</p>
<p>ISR是由leader维护，follower从leader同步数据有一定延迟（(延迟时间)replica.lag.time.max.ms和（延迟条数，0.10已取消）replica.lag.max.message），超过任意一个阈值就会将follower从ISR中剔除存储到OSR列表（新加入的follower也会放在这里）</p>
<h2 id="分区策略有哪些"><a href="#分区策略有哪些" class="headerlink" title="分区策略有哪些"></a>分区策略有哪些</h2><p>分区的作用是提供负载均衡的能力，实现系统的高伸缩性。分区策略是决定将producer发送的消息分配到哪个分区的算法。</p>
<ul>
<li>轮询策略：按照分区顺序分配</li>
<li>随机策略：将消息随机放到任意一个分区上</li>
<li>key-ordering策略：消息中的业务key可以保证同一个key的所有消息都进入同一个分区，因为消息处理在同一个分区是有序的，因此也被叫做按消息key顺序策略。</li>
</ul>
<h2 id="哪些场景使用了零拷贝"><a href="#哪些场景使用了零拷贝" class="headerlink" title="哪些场景使用了零拷贝"></a>哪些场景使用了零拷贝</h2><p>mmap的索引：索引是基于MappedByteBuffer的，也是让用户态和内核态共享的数据缓冲区，此时，数据不需要复制到用户态空间。</p>
<p>日志文件读写用到的TransportLayer：TransportLayer是kafka传输层的接口，它的实现类使用了fileChannel的transferTo方法，该方法底层使用sendfile实现了零拷贝。如果I/O通道使用普通的PLAINTEXT，那么，Kafka就可以利用Zero Copy特性，直接将页缓存中的数据发送到网卡的Buffer中，避免中间的多次拷贝。相反，如果I/O通道启用了SSL，那么，Kafka便无法利用Zero Copy特性了。</p>
<h2 id="sendFile和mmap的区别"><a href="#sendFile和mmap的区别" class="headerlink" title="sendFile和mmap的区别"></a>sendFile和mmap的区别</h2><p>sendfile：在Linux2.1版本提供sendfile()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 参数：目标文件描述符，原文件描述符，源文件偏移量，拷贝数据的长度</span></span><br></pre></td></tr></table></figure>

<p>Linux内核2.4版本，对于支持网卡SG-DMA技术下，sendfile系统调用的过程发生了变化。可以直接将内核缓冲区的描述符和长度发送到socket缓冲区，不需要拷贝，这样就减少了一次数据拷贝。</p>
<p>sendfile只需要两次上下文切换，2次数据拷贝，拷贝都是用DMA（直接内存访问的方法）来完成不需要CPU参与。</p>
<p>mmap：需要4次上下文切换，3次拷贝。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure>

<p>mmap调用后，DMA会将数据从磁盘拷贝到内核缓冲区，然后应用进程和操作系统共享这个缓冲区。</p>
<p>进程调用write，操作系统将内核缓冲区的数据拷贝到socket缓冲区，上下文切换到内核态，由CPU来完成搬运数据。</p>
<p>最后再由DMA将socket缓冲区的数据拷贝到网卡缓冲区。</p>
<p>sendFile相当于是原汁原味地读写，直接将硬盘上的文件送给网卡，但这种方式并不一定对所有场景都适用，比如如果你需要从硬盘上读取文件，然后经过一定修改之后再送给网卡的情况下，就不适合用sendFile,，需要使用mmap。</p>
<h2 id="leader选举策略有哪些"><a href="#leader选举策略有哪些" class="headerlink" title="leader选举策略有哪些"></a>leader选举策略有哪些</h2><ul>
<li>OfflinePartition Leader选举：每当有分区上线时，就需要执行Leader选举。所谓的分区上线，可能是创建了新分区，也可能是之前的下线分区重新上线。这是最常见的分区Leader选举场景。</li>
<li>ReassignPartition Leader选举：当你手动运行kafka-reassign-partitions命令，或者是调用Admin的alterPartitionReassignments方法执行分区副本重分配时，可能触发此类选举。假设原来的AR是[1，2，3]，Leader是1，当执行副本重分配后，副本集合AR被设置成[4，5，6]，显然，Leader必须要变更，此时会发生Reassign Partition Leader选举。</li>
<li>PreferredReplicaPartition Leader选举：当你手动运行kafka-preferred-replica-election命令，或自动触发了Preferred Leader选举时，该类策略被激活。所谓的Preferred Leader，指的是AR中的第一个副本。比如AR是[3，2，1]，那么，Preferred Leader就是3。</li>
<li>ControlledShutdownPartition Leader选举：当Broker正常关闭时，该Broker上的所有Leader副本都会下线，因此，需要为受影响的分区执行相应的Leader选举。</li>
</ul>
<p>这4类选举策略的大致思想是类似的，即从AR中挑选首个在ISR中的副本，作为新Leader。</p>
<h2 id="kafka为什么不支持读写分离？"><a href="#kafka为什么不支持读写分离？" class="headerlink" title="kafka为什么不支持读写分离？"></a>kafka为什么不支持读写分离？</h2><p>主要是如果主写从读有两个明显的缺点</p>
<p>1、数据一致性问题：数据从主节点转移到从节点必然会有一个延时的时间窗口，这个时间窗口会导致主从节点之间的数据不一致。例如在某时刻，主节点和从节点中的A=X，之后主节点更新了A=Y，在同变更通知到从节点之前，从节点还是旧数据，这时候如果读从节点就会导致数据不一致问题。</p>
<p>2、延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经历<code>网络→主节点内存→网络→从节点内存</code>这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历<code>网络→主节点内存→主节点磁盘→网络→从节点内存→从节点磁盘</code>这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</p>
<h2 id="kafka如何保证高可用？"><a href="#kafka如何保证高可用？" class="headerlink" title="kafka如何保证高可用？"></a>kafka如何保证高可用？</h2><p>kafka多个broker组成一个集群，每个broker是一个节点，当创建一个topic时，这个topic会被划分成多个paration，每个paration可以存在不同的broker上，每个paration只存放一部分数据。</p>
<p>这就是天然的分布式消息队列，一个topic的数据分散在多台机器上，每个机器只存放一部分数据。</p>
<p>在0.8版本之前是没有高可用机制的，任何一台broker宕机就会提供读写服务。</p>
<p>在0.8以后提供了HA机制，每个paration上的数据会同步到其他机器形成自己的多个replication副本，所有replication会选举一个leader，其他副本是follower，读写都是在leader上完成，数据写完之后leader会同步到follower。这样提供容错性。</p>
<p>拥有了replica副本机制，如果某个broker宕机了，这个broker的paration还在其他机器上存有副本，如果leader宕机就会重新从follower中选取新的leader继续提供读写服务。</p>
<p>写数据的时候，生产者只将数据写入leader节点，leader节点会将数据写入到本地磁盘，然后其他follower会主动从leader拉取最新的数据，follow同步完成之后发送ack到leader，leader收到所有follower的ack之后，就会返回写成功的消息给生产者。</p>
<p>消费数据的时候，consumer只从leader上取数据，但是只有当一个消息已经被所有follower同步完成后，这个消息才会被消费。</p>
<h2 id="Consumer-Rebalance机制"><a href="#Consumer-Rebalance机制" class="headerlink" title="Consumer Rebalance机制"></a>Consumer Rebalance机制</h2><p>发生的条件</p>
<ol>
<li>消费者组成员数发生变化</li>
<li>订阅的topic的分区数发生变化</li>
<li>topic数量发生变化</li>
</ol>
<p>rebalance事件通过消费端的心跳线程通知到其他consumer实例。</p>
<p>消费者组的状态流转</p>
<p><img src="/posts/5bbc7517/image.png" alt="image.png"></p>
<p>状态的含义</p>
<p><img src="/posts/5bbc7517/image-1677922518290.png" alt="image.png"></p>
<p>重平衡的流程</p>
<ol>
<li>选择组协调器。每个消费者组都会选一个broker作为自己组的组协调器，负责监控消费者组里所有消费者的心跳判断是否宕机，然后开启消费组的Rebalance。</li>
<li>消费者向GroupCoordinator发送加入消费者组 JoinGroup请求，然后第一个加入到消费者组的consumer就是leader，leader负责指定分区方案。</li>
<li>等待leader consumer分配方案。leader通过给组协调者发送SyncGroup请求，然后组协调者将分区分配方案发送给各个consumer。</li>
</ol>
<p>Leader Consumer的任务是收集所有成员的订阅信息，然后根据这些信息，制定具体的分区消费分配方案。</p>
<h2 id="消费者组Rebalance分区分配策略"><a href="#消费者组Rebalance分区分配策略" class="headerlink" title="消费者组Rebalance分区分配策略"></a>消费者组Rebalance分区分配策略</h2><p>主要有三种策略，range，round-robin，sticky。客户端通过设置参数<code>paration.assignment.strategy</code>来设置消费者和订阅topic之间的分区分配策略。</p>
<p>默认情况下是range策略。</p>
<ul>
<li>range：按照分区序号排序，n=分区数$/$消费者数，m=​分区数%消费者数​,前m个consumer每个分配n+1个paration，剩下的分配n个paration。</li>
<li>round-robin：轮寻分配</li>
<li>sticky：分配分区尽可能均匀，如果一个consumer挂了，他所负责消费的分区会均分给剩下活跃的consumer</li>
</ul>
<h2 id="kafka和RocketMQ的对比"><a href="#kafka和RocketMQ的对比" class="headerlink" title="kafka和RocketMQ的对比"></a>kafka和RocketMQ的对比</h2><p>单机吞吐量</p>
<ul>
<li>Kafka大概17.3w/s，rocketMQ吞吐量在11.6w/s。(Kafka吞吐量高的原因是Producer端将多个小消息合并再序列化后批量发送到Broker，RocketMQ没有这么做的原因是在发送端缓存过多消息GC是个问题)</li>
</ul>
<p>数据可靠性</p>
<ul>
<li><p>RocketMQ支持同步，异步刷盘，异步复制</p>
</li>
<li><p>Kafka使用异步刷盘，同步复制/异步复制</p>
</li>
</ul>
<p>消息投递实时性</p>
<ul>
<li>kafka使用短路安迅方式拉去消息，实时性取决于间隔时间，0.8以后版本支持长轮询。</li>
<li>RocketMQ使用长轮询，消息投递延时通常是在毫秒级别。</li>
</ul>
<p>消息失败重试</p>
<ul>
<li>kafka消费失败不支持重试</li>
<li>RocketMQ消费失败支持定时重试，每次重试时间间隔顺延</li>
</ul>
<p>严格的顺序</p>
<ul>
<li>Kafka和RocketMQ都支持顺序消息</li>
</ul>
<p>定时消息</p>
<ul>
<li>Kafka不支持定时消息，RocketMQ支持两类定时消息，开源版本支持秒级定时，阿里云版本支持毫秒级别延时</li>
</ul>
<p>分布式事务消息</p>
<ul>
<li>Kafka不支持事务消息，RocketMQ支持分布式事务消息</li>
</ul>
<p>消息查询</p>
<ul>
<li>Kafka不支持消息查询</li>
<li>RocketMQ支持根据消息标识查询消息，也支持根据消息内容查询消息</li>
</ul>
<p>消息并行度</p>
<ul>
<li>Kafka小的并行度依赖Topic配置的分区数</li>
<li>RocketMQ并行度在顺序消费时和Kafka一致，伦旭取决于Consumer线程数，如Topic配置10个队列，10台Consumer，每台机器100个线程那么并行度就是1000</li>
</ul>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/posts/ae9b5bb0/</url>
    <content><![CDATA[<blockquote>
<p>spring bean 的生命周期，循环依赖的实现，IOC，AOP的原理，Spring MVC的请求处理流程</p>
</blockquote>
<span id="more"></span>

<h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2093aa3ef5f48c294068323a3e095e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="bean生命周期"></p>
<h2 id="为何需要三级缓存解决对象的循环依赖，二级缓存不行吗"><a href="#为何需要三级缓存解决对象的循环依赖，二级缓存不行吗" class="headerlink" title="为何需要三级缓存解决对象的循环依赖，二级缓存不行吗"></a>为何需要三级缓存解决对象的循环依赖，二级缓存不行吗</h2><p>Spring 使用三级缓存解决循环依赖的原因是为了支持AOP动态代理，如果只使用二级缓存，那么在AOP创建代理对象时，注入到其他bean的可能不是最终的代理对象而是原始的bean，这样会导致AOP失效或者出现异常。三级缓存的作用是在bean完成初始化后，但是没有放入到二级缓存之前，对bean进行动态代理的增强处理，并将代理对象放入二级缓存，同时将原先的代理对象从第三级缓存中删除，这样保证了注入到其他bean的都是经过AOP增强的同一个代理对象（默认是单例）。</p>
<h2 id="Spring-IOC的实现原理"><a href="#Spring-IOC的实现原理" class="headerlink" title="Spring IOC的实现原理"></a>Spring IOC的实现原理</h2><p>IOC（控制反转）是依赖倒置原则的设计思路。将原先代码中需要实现的对象创建，对象依赖管理，交给IOC容器管理。</p>
<p>Spring IOC容器通过xml/注解方式来配置类和类之间的依赖关系，完成对象的创建和依赖管理，主要涉及到的模式就是工厂模式。</p>
<p><img src="/posts/ae9b5bb0/18796269-94421d32a8342c99-1677734223834.png" alt="factory"></p>
<h3 id="IOC的优点"><a href="#IOC的优点" class="headerlink" title="IOC的优点"></a>IOC的优点</h3><ul>
<li>集中管理对象的生命周期，实现类的可配置化，更容易管理对象之间的依赖关系</li>
<li>降低类之间的耦合度</li>
</ul>
<p>IOC做的事其实就是，低级容器（BeanFactory）加载配置文件，解析成BeanDefinition，然后放到一个map里，BeanName作为key ，这个Bean实例化的对象作为value，  使用的时候调用getBean方法，完成依赖注入。 </p>
<p>至于高级容器 （ApplicationContext），它包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等.</p>
<h2 id="Spring-AOP的实现原理"><a href="#Spring-AOP的实现原理" class="headerlink" title="Spring AOP的实现原理"></a>Spring AOP的实现原理</h2><p>AOP面向切面编程的编程思想，是OOP编程的有效补充，使用AOP技术，可以将一些系统相关的代码提取出来通过切面进入系统，从而避免在业务逻辑代码中混入很多的系统相关的逻辑（日志记录，事务管理，权限控制等）。</p>
<h3 id="AOP使用的优点："><a href="#AOP使用的优点：" class="headerlink" title="AOP使用的优点："></a>AOP使用的优点：</h3><ul>
<li>降低模块代码之间的耦合度</li>
<li>系统更容易扩展</li>
<li>提高代码的复用性</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>连接点（JoinPoint）：需要在程序中插入横切关注点的点，连接点可能是在类初始化、方法调用、字段调用或处理异常等等。Spring中只支持方法执行连接点。</p>
</li>
<li><p>切入点（Pointcut）：一组相关连接点的集合。</p>
</li>
<li><p>通知（Advice）：在连接点上执行的行为，增强提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括前置增强（before advice）、后置增强 (after advice)、环绕增强 （around advice）。</p>
</li>
<li><p>切面（Aspect）：通知和切入点的结合。</p>
</li>
<li><p>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程。</p>
</li>
<li><p>代理（Proxy）：通过代理方式来对目标对象应用切面。AOP代理可以用JDK动态代理或CGLIB代理实现。</p>
</li>
<li><p>目标对象（Target）：需要被织入关注点的对象。即被代理的对象。</p>
</li>
</ol>
<p><img src="/posts/ae9b5bb0/18796269-73cc3e80c1a96413-1677747010831.webp" alt="img"></p>
<h3 id="AOP的实现："><a href="#AOP的实现：" class="headerlink" title="AOP的实现："></a>AOP的实现：</h3><ul>
<li>静态代理：AspectJ ，在编译期间会添加AOP代码到Java类文件中。</li>
<li>动态代理：JDK自带的动态代理和CGlib动态代理。</li>
</ul>
<h2 id="动态代理和静态代理，JDK自带的动态代理和CGlib的区别"><a href="#动态代理和静态代理，JDK自带的动态代理和CGlib的区别" class="headerlink" title="动态代理和静态代理，JDK自带的动态代理和CGlib的区别"></a>动态代理和静态代理，JDK自带的动态代理和CGlib的区别</h2><p>动态代理的实现方式有两种，一种是基于接口的动态代理，另一种是基于类的动态代理。</p>
<ul>
<li>基于接口的动态代理，使用JDK官方的Proxy类创建代理对象，要求代理的目标对象必须实现接口。JDK动态代理是通过反射创建代理对象。</li>
<li>基于类的动态代理使用CGlib的Enhancer类创建代理对象，可以对没有实现接口的类进行代理，原理是通过ASM字节码生成技术，运行期动态生成新的<code>Class</code>，创建原始类的子类，进而创建代理对象。</li>
</ul>
<p>CGlib 的 FastClass 机制是一种优化方法，用于避免使用 Java 反射来调用目标类的方法。FastClass 机制的原理是：</p>
<ul>
<li>CGlib 会为目标类和代理类各生成一个 FastClass 类，这个类会继承 FastClassByCGLIB 类，并且包含一个 invoke 方法。</li>
<li>invoke 方法的参数是一个整数 index，一个对象数组 args 和一个 Class[] types。index 表示要调用的目标类或代理类的方法编号，args 表示要传递的参数，types 表示参数的类型。</li>
<li>invoke 方法会根据 index 和 types 来确定要调用的具体方法，并且使用强制类型转换和硬编码的方式来直接调用该方法，而不需要通过反射。</li>
<li>CGlib 会为每个方法生成一个唯一的 index，并且在 FastClass 类中维护一个数组来存储这些 index。这样就可以通过 index 快速定位到要调用的方法。</li>
</ul>
<h2 id="反向代理和正向代理"><a href="#反向代理和正向代理" class="headerlink" title="反向代理和正向代理"></a>反向代理和正向代理</h2><p>正向代理中，Proxy和client属于一个LAN，对于server端来讲是透明的。</p>
<p>反向代理中，Proxy和server同属一个LAN，对于客户端来讲是透明的。</p>
<p>正向代理可以用来访问客户端无法访问的资源，可以做缓存加速，客户端授权认证。</p>
<p>反向代理可以用来做负载均衡，保护server端的安全，组织web攻击。</p>
<img src="/posts/ae9b5bb0/305504-20161112125907030-1432469707.png" alt="img" style="zoom:70%;">



<h2 id="Spring-MVC请求的处理流程"><a href="#Spring-MVC请求的处理流程" class="headerlink" title="Spring MVC请求的处理流程"></a>Spring MVC请求的处理流程</h2><p>前端请求发送到DispatchServlet，DispatchServlet负责转发请求到HandlerMapping，从handlerMapping中获取到handle，然后通过handler获取handlerAdapter，根据适配器执行handler方法（业务方法），返回modelAndView对象，之后通过ViewResolver解析ModelAndView返回页面。主要在获取 handlerAdapter  后，会先执行拦截器方法，然后才执行真正的handler 方法。</p>
<p><img src="/posts/ae9b5bb0/h8202u7yaw.png" alt="img"></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/78ba8bafb90a">理解Spring的AOP和IOC实现原理 - 简书 (jianshu.com)</a></p>
<p><a href="https://juejin.cn/post/6963589313317568543">https://juejin.cn/post/6963589313317568543</a></p>
<p><a href="https://juejin.cn/post/7181827086552662053">Spring 为何需要三级缓存解决循环依赖？ - 掘金 (juejin.cn)</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq</title>
    <url>/posts/3e7adddd/</url>
    <content><![CDATA[
<p>MQ（message Queue）：翻译为消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入…</p>


<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是MQ？"><a href="#什么是MQ？" class="headerlink" title="什么是MQ？"></a>什么是MQ？</h3><p>MQ（message Queue）：翻译为消息队列，通过典型的生产者和消费者模型，生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间的解耦。别名为消息中间件。通过利用高效可靠的消息传递机制进行平台无关的数据交流，并给予数据通信来进行分布式系统的集成。</p>
<h3 id="MQ有哪些？"><a href="#MQ有哪些？" class="headerlink" title="MQ有哪些？"></a>MQ有哪些？</h3><p>老牌的ActiveMQ、RabbitMQ、当今热门的Kafka,阿里巴巴自主开发的RocketMQ等。</p>
<h3 id="不同的MQ的特点"><a href="#不同的MQ的特点" class="headerlink" title="不同的MQ的特点"></a>不同的MQ的特点</h3><p><strong>ActiveMQ</strong>是由Apache出品的一款开源消息中间件，旨在为应用程序提供高效、可扩展、稳定、安全的企业级消息通信。ActiveMQ实现了JMS 1.1 并提供了很多附加的特性，比如JMX管理、主从管理、消息组通信、消息优先级、延迟接收消息、虚拟接收者、消息持久化、消息队列监控等。主要特性如下：</p>
<ul>
<li>支持Java、C、C++、C#、Ruby、Perl、Python、PHP等多种语言的客户端和协议，如OpenWire、STOMP、AMQP、MQTT协议。</li>
<li>提供了像消息组通信、消息优先级、延迟接收消息、虚拟接收者、消息持久化之类的高级特性。</li>
<li>完全支持JMS 1.1 和 J2EE 1.4 规范 (包括持久化、分布式事务消息、事务)</li>
<li>支持Spring框架，ActiveMQ 可以通过Spring 的配置文件方式很容易嵌入Spring应用中。</li>
<li>通过了常见的J2EE服务器测试，比如TomEE、Geronimo、JBoss、GlassFish、WebLogic。</li>
<li>连接方式多样化，ActiveMQ 提供了多种连接方式，例如 in-VM、TCP、SSL、NIO、UDP、多播、JGroups、JXTA。</li>
<li>支持通过使用JDBC 和 Journal 实现消息的快速持久化。</li>
<li>为高性能集群、客户端-服务器、点对点通信等场景而设计。</li>
<li>提供了技术和语言中立的REST API 接口。</li>
<li>支持以AJAX 方式调用 ActiveMQ。</li>
<li>ActiveMQ 可以轻松地与CXF、Axis 等 WebService 技术整合，以提供可靠的消息传递。</li>
<li>可以作为内存中的JMS 提供者，非常适合 JMS 单元测试。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="限流削峰"><a href="#限流削峰" class="headerlink" title="限流削峰"></a>限流削峰</h4><p>MQ可以将系统中超量的请求暂时存在其中，以便于后期可以慢慢处理，从而避免了请求的丢失或者系统被大流量打垮。</p>
<h4 id="异步解耦"><a href="#异步解耦" class="headerlink" title="异步解耦"></a>异步解耦</h4><p>上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量和并发度，且系统耦合度太高。异步调用则会解决这个问题。</p>
<h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><p>通过MQ可以收集业务日志，用户行为等数据。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><p>RocketMQ由Producer、Consumer、Broker三部分组成，Produce负责生产消息，Consumer负责消费消息，Broker负责存储消息，Broker在实际部署过程中对应一台服务器，每个Broker可以存储多个Topic的消息，每个Topic消息可以分片存储于不同的Broker。Message Queue用于存储消息的物理地址，每个Topic中的消息地址存储于多个Message Queue中。Consumer Group由多个Consumer实例构成。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>泛指所传输信息的物理载体，生产和消费的最小数据单位，每条消息必须属于一个主题。RocketMQ中每个消息都拥有唯一的MessageID，并且可以携带具有业务标识的key，系统提供了通过Message ID和Key查询消息的功能。</p>
<h3 id="Topic主题"><a href="#Topic主题" class="headerlink" title="Topic主题"></a>Topic主题</h3><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>消息的标签，用于区分同一主题下的不同类型的消息，来自同一业务单元的消息，可以根据不同业务目的在同一个主题下设置不同的标签。标签能够有效保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>一个消息生产者会把业务应用系统里产生的消息发送到broker服务器，RocketMQ提供多种发送方式。同步发送，异步发送，顺序发送，单向发送。同步和异步方式均需要broker返回确认消息，单向发送不需要。</p>
<p>消息生产者支持分布式集群方式部署。通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息，并将消息提供给应用程序。从用户的角度是提供了两种方式，拉取式消费和推送式消费。支持分布式集群方式部署，支持push推和pull拉两种方式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求.</p>
<h3 id="Broker-Server"><a href="#Broker-Server" class="headerlink" title="Broker Server"></a>Broker Server</h3><p>代理服务器，负责存储转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储，同时为消费者的拉取请求做准备。代理服务器页存储消息相关的元数据信息（消息进度偏移量，主题，队列消息等）。</p>
<h3 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h3><p>名称服务充当路由信息的提供者。生产者或消费者能够通过名字服务查找各个主题相应的Broker IP列表。多个NameServer实例组成的集群，但是相互独立，没有信息交换。类似于Dubbo中的zookeeper,支持Broker的动态注册与发现,主要包括两个功能,一个是Broker管理，另一个是路由信息管理.NameServer接收Broker集群的注册信息并且保存下来作为路由信息的基本数据.然后提供心跳检测机制,检查Broker是否还能存活;路由信息管理,每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息然后Producer和Consumer提供NameServer就能知道整个Broker的路由信息,从而进行投递和消费.NameServer通常也是集群部署,各个实例之间不进行通信.Broker是向每台NameServer注册自己的路由信息,所以每个NameServer实例上面都保存一份完整的路由信息.当某个NameServer因为某种原因下线了,Broker仍然可以向其他NameServer同步路由信息,Producer和Consumer仍然可以动态感知Broker的路由信息。</p>
<h3 id="拉取式消费"><a href="#拉取式消费" class="headerlink" title="拉取式消费"></a>拉取式消费</h3><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉取消息，主动权由应用控制，一旦获取了批量信息，应用就会启动消费过程。</p>
<h3 id="推动式消费"><a href="#推动式消费" class="headerlink" title="推动式消费"></a>推动式消费</h3><p>Consumer的另一种消费方式，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<h3 id="生产者组"><a href="#生产者组" class="headerlink" title="生产者组"></a>生产者组</h3><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致，如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会练习同一生产者实例以提交或者回溯消息。</p>
<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>同类Consumer的集合。要求这类消费者消费逻辑一致，消费的是同一类消息。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易，要注意的是，消费者组的消费者实例必须订阅完全相同的Topic，RocketMQ支持两种消息模式：集群消费和广播消费。</p>
<h3 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h3><p>相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h3 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h3><p>相同Consumer Group的每个Consumer实例都全量接收消息。</p>
<h3 id="普通顺序消息"><a href="#普通顺序消息" class="headerlink" title="普通顺序消息"></a>普通顺序消息</h3><p>在该模式下，消费者通过同一个消息队列收到的消息是有顺序的，不同的消息队列收到的消息则可能是无顺序的。</p>
<h3 id="严格顺序消息"><a href="#严格顺序消息" class="headerlink" title="严格顺序消息"></a>严格顺序消息</h3><p>消费者收到的消息都是严格有序的。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="消息的订阅与发布"><a href="#消息的订阅与发布" class="headerlink" title="消息的订阅与发布"></a>消息的订阅与发布</h3><p>消息的发布是指某个生产者向某个topic发送消息，消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p>
<h3 id="消息的有序"><a href="#消息的有序" class="headerlink" title="消息的有序"></a>消息的有序</h3><p>消息的有序是指一类消息消费时，能按照发送的顺序来消费，例如：一个订单残生了三个消息分别是创建订单，订单付款，订单完成，消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格保证消息的有序。</p>
<p>顺序消息分为全局顺序消息和分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一个组消息被顺序消费就可以。</p>
<p>全局顺序的适用场景：对于指定的topic，所有消息按照严格的FIFO发布和消费，适用于性能要求不高，所有的消息严格按照FIFO原则进行消息发布和消费的场景。</p>
<p>分区顺序的适用场景：针对的是同一个Topic中根据sharding key进行区块分区。同一个分区内的消息按照严格的FIFO顺序进行发布和消费。Sharding key是用来区分不同分区的关键字段，和不同的key是不同的概念，适用于性能要求很高，在同一个区块中严格按照FIFO原则进行消息发布和消费的场景。</p>
<h3 id="消息的过滤"><a href="#消息的过滤" class="headerlink" title="消息的过滤"></a>消息的过滤</h3><p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤，消息过滤目前是Broker端实现的，有点事减少对于Consumer无用的网络传输，缺点是增加了Broker的负担，而且实现相对复杂。</p>
<h3 id="对消息可靠性的影响因素"><a href="#对消息可靠性的影响因素" class="headerlink" title="对消息可靠性的影响因素"></a>对消息可靠性的影响因素</h3><ol>
<li>Broker非正常关闭</li>
<li>Broker异常Crash</li>
<li>操作系统Crash</li>
<li>机器掉电但是能立即恢复供电情况</li>
<li>机器无法开机（可能是CPU，主板，内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>1、2、3、4四种情况属于硬件资源可以例子恢复的情况，在这几种情况下可以保证消息不丢失或者丢失少量消息。5，6情况属于单点故障且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可以保证99%的消息不丢但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场景，例如对金额的实时计算。</p>
<h3 id="至少一次（At-least-once）"><a href="#至少一次（At-least-once）" class="headerlink" title="至少一次（At least once）"></a>至少一次（At least once）</h3><p>至少一次是指每个消息至少投递一次，Consumer先拉取到本地，消费完之后才会返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持该特性。</p>
<h3 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h3><p>回溯消费是指Consumer已经消费成功，但由于业务需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留，并且重新消费一般是按照时间维度，例如Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度回退消费进度，回退的时间维度精确到毫秒。</p>
<h3 id="事务消息和定时消息"><a href="#事务消息和定时消息" class="headerlink" title="事务消息和定时消息"></a>事务消息和定时消息</h3><p>事务消息是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败，RocketMQ的事务消息提供X/Open XA的分布式功能，通过事务消息能达到分布式事务的最终一致性。</p>
<p>定时消息（延迟队列）是指消息发送到Broker后，不会立即被消费，等待特定时间投递给真正的topic，broker由配置项messageDelayLevel，默认是18个等级，“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，这个延后时间等级可以自定义，需要注意的是messageDelayLevel是Broker的属性，不属于某个topic，发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。</p>
<ul>
<li>当level==0,消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1秒</li>
<li>当level&gt;maxLevel，则level==maxLevel</li>
</ul>
<p>定时消费会暂存在名为SCHEDULE_TOPIC_XXX的topic中，并根据delayTimeLevel存入特定的queue，queueId=delayTimeLevel-1，即一个queue只存在相同的延迟消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度消费SCHEDULE_TOPIC_XXXX,将消息写入真实的topic。需要注意的是，定时消息还在第一次写入和调度写入时都会计数，因此发送数量，tps都会变高。</p>
<h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>Consumer消费失败之后，要提供重试机制，让消息再消费一次。消息消费失败的原因</p>
<ul>
<li>由于消息本身的原因，例如序列化失败，消息数据本身因为业务无法处理等，这种错误通常要跳过这个消息，再消费其他消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，过10s后再重试。</li>
<li>由于依赖的下有服务不可用也会造成消费失败，这种情况即使跳过这条消息，其他消息也会报错，应该建议应用sleep30s，再消费下一条消息，这样可以减轻Broker重试消费的压力。</li>
</ul>
<h3 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h3><p>消息重投保证消息尽可能发送成功，不丢失但可能会造成重复消费，消息重复在RocketMQ是无法避免的问题，消息重复在一般情况下不会发生当出现消息量大，网络抖动，消息重复就会是大概率事件，另外生产者主动重发，consumer负载变化也会导致重复消息。</p>
<p>消息重试策略</p>
<ul>
<li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed+ 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li>
<li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li>
<li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p>
<p>生产者流量控制：</p>
<ol>
<li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认是1000ms，返回流控。</li>
<li>如果开启transientStorePollEnable==true，且broker为异步刷盘的主机，transientStorePool中资源不足，拒绝当前send请求，返回流控。</li>
<li>Broker每个10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsLnSendQueue，默认200ms，拒绝当前send请求，返回流控。</li>
<li>broker通过拒绝send请求方式实现流量控制</li>
</ol>
<p>生产者流控不会尝试消息重投。</p>
<p>消费者流量控制：</p>
<ul>
<li>消费者本地缓存消息数超过pillThresholdForQueue时，默认1000。</li>
<li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB</li>
<li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认是2000。</li>
</ul>
<p>消费者流量控制的结果是拉取频率。</p>
<h3 id="什么是死信队列"><a href="#什么是死信队列" class="headerlink" title="什么是死信队列"></a>什么是死信队列</h3><p>死信队列是处理无法被正常消费的消息。当一条消息初次消费失败后，消息队列会对进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确的消费该消息，此时，消息队列不会立刻丢弃这条消息，而是将他存储在死信队列中。RocketMQ可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序是指可以按照消息的发送顺序来消费。RocketMQ分给分区有序和全局有序。</p>
<p>顺序消费的原理：在默认情况下消息发送会采用轮询的方式将消息发送到不同的queue（分区队列）；而消费消息的时候从多个queue中拉取消息，这种情况发送和消费是不能够保证有序，但是如果发送的消息只发送到同一个queue，消费的时候只从这个queue中取消息，就能保证顺序，当发送和消费参与的queue只有一个，则是全局有序；如果有多个queue参与，则为分区有序，也就是相对每个queue，消息都是有序的。</p>
<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>使用场景：比如提交一个订单之后就可以发送一个延时消息，1小时候后检查这个订单状态，如果还是未支付就释放库存。</p>
<p>RocketMQ并不支持任意时间的延时，需要设置几个固定的延时等级，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>消息发送的时间和设置的等级与重试次数有关。</p>
<p>想要批量发送消息的条件是这些消息应该有相同的topic，相同的waitStoreMsgOK，并且不能是延时消息，此外这批消息的总大小不应该超过4MB。</p>
<p>根据标签过滤消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br><span class="line"><span class="comment">// 消费者将接收TAGA,TAGB,TAGC的消息，但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用，在这种情况下，可以使用SQL表达式筛选消息。</span></span><br></pre></td></tr></table></figure>

<p>只有使用push模式的消费者才能用使用SQL92标准的sql语句</p>
<p> public void subscribe(final String topic, final MessageSelector messageSelector)</p>
<p>生产者可以通过putUserProperty()方法来设置消息的属性。</p>
<h2 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h2><p>整体架构采用的是混合型存储结构，单个Broker实例下的所有队列共用一个commitlog。也就是多个topic的内容都存储到一个CommitLog中，只要Broker端采用同步或者异步的方式将消息保存到CommitLog中就不会丢失消息。服务端支持长轮询模式，如果一个消息拉去请求没有拉到消息，Broker允许等待30s，只要在这段时间内有新消息到达，将直接返回给消费端。</p>
<ol>
<li>CommitLog：消息主题以及元数据的存储主题，存储生产者写入的消息主题内容，消息内容不是定长的，单个文件大小默认是1G，文件名长度20位，左边补充0，剩余是起始偏移量。消<strong>息是顺序写入到日志文件的</strong>，当文件写满之后再写下一个文件。顺序写入磁盘是随机写效率的6000倍。</li>
<li>ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，主要用来存储消息在commitlog的索引。由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件根据topic检索是非常低效的，ConsumeQueue作为消费消息的索引，保存指定topic下的队列消息在commitlog中的其实物理偏移量offset，消息大小size,tag的hashcode值，consumequeue文件可以看成是基于topic的commitlog索引文件，所以具体存储路径是$HOME/store/consumequeue/{topic}/{queueId}/{fileName}，consumequeue文件采取定长设计，每个条目一共20个字节，单个文件由30w个条目组成，可以像数组一样随机访问每个条目，每个ConsumeQueue文件大小大约5.72M。</li>
<li>IndexFile：索引文件提供一种可以通过key或者时间区间来查询消息的方法。Index文件的存储位置是$HOME \store\index${fileName}，文件名是以创建时间戳命名的，固定单个IndexFile文件大小约400M，一个IndexFile可以保存2000W个索引，索引文件底层实现是hash索引。</li>
</ol>
<p><strong>页缓存：</strong>是操作系统对文件的缓存，用于加速对文件的读写，一般来讲，顺序读写的速度几乎接近于内存的读写速度，主要原因就是使用了PageCache机制对读写访问操作进行了优化，将一部分内存用作页缓存。写的时候先写入到PageCache，随后通过异步的方式同步到物理磁盘上，对于读取操作，如果未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对相邻的数据预读取。</p>
<p><strong>零拷贝</strong>：RocketMQ利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种mmap的方式减少了一次从操作系统内核缓冲区到用户应用地址空间的缓冲区的拷贝），从而极大底稿了文件的读写效率。</p>
<p>消息刷盘</p>
<ul>
<li>同步刷盘：只有消息真正持久化到磁盘后，Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来讲是一种不错的保障，但是性能上会有较大影响，但是这种相比于异步刷盘更安全，因此常用于金融业务。</li>
<li>异步刷盘：只要消息写入到PageCache，即可将成功的ACK返回给Producer端，消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提供性能和吞吐量。</li>
</ul>
<h2 id="消息的高可用性"><a href="#消息的高可用性" class="headerlink" title="消息的高可用性"></a>消息的高可用性</h2><p>RocketMQ分布式集群是通过MASTER和Slave的配合达到高可用性的。</p>
<p>Master和Slave的区别：在Broker的配置文件中，参数brokerId的值为0表明这个Broker是Master，大于0表名这个是Slave。brokerRole参数也会说明这个Broker是Master还是Slave。</p>
<p>Producer只能和Master角色的Broker连接写入消息；Consumer两者都可以连接读取消息。</p>
<h3 id="消费端高可用"><a href="#消费端高可用" class="headerlink" title="消费端高可用"></a>消费端高可用</h3><p>当Master繁忙或者不可用的时候，Consumer可以自动切换到Slave读，有了自动切换Consumer，可以保证消费端的高可用。</p>
<h3 id="发送端高可用"><a href="#发送端高可用" class="headerlink" title="发送端高可用"></a>发送端高可用</h3><p>producer发送消息时，将Topic的多个Message Queue创建在多个Broker组上（Broker名字相同，Id不同），当一个Broker组的Master不可用之后，Producer仍然可以发送消息。RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足，需要手动停止Slave，更改配置文件，用新的配置文件启动Broker。</p>
<h2 id="消息的主从复制"><a href="#消息的主从复制" class="headerlink" title="消息的主从复制"></a>消息的主从复制</h2><p>同步复制：Master和Slave均要写成功之后才会反馈给客户端。</p>
<p>如果Master出现故障，Slave上全部的备份数据，容易恢复，但是同步复制会增大数据写入延迟，降低系统的吞吐量。</p>
<p>异步复制：只要Master写成功就会反馈给客户端写成功状态。异步复制具有较低的延迟和高吞吐量，但是当Master出现故障，这时Slave上的数据有可能是不完整的，因此会出现消息丢失，不可靠。</p>
<p>配置文件：brokerRole=ASYNC_MASTER/SYNC_MASTER/SLAVE；异步，同步都是在主Broker配置的，如果是从Broker配置成Slave。</p>
<p>通常使用时，会将刷盘方式配置成异步刷盘，主从复制配置成同步复制。</p>
<h2 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h2><p>rocketMQ的基本通讯过程如下</p>
<ol>
<li>Broker启动之后需要完成一次将自己注册到NameServer的操作；随后每隔30s时间向NameServer上报Topic信息。</li>
<li>消息生产者作为客户端发送消息的时候，需要根据消息的topic从本地缓存的TopicPublishInfoTable中获取路由信息，如果TopicpushinfoTable中没有信息就会从NameServer上重新拉起一次消息并更新TopicPublishInfoTable。</li>
<li>producer从路由信息中选择一个队列进行消息发送；Broker作为消息的接受者接收消息并落盘存储。</li>
<li>消息消费者获取路由信息并完成客户端的负载均衡后，选择其中的一个或者几个消息队列来拉取消息并进行消费。</li>
</ol>
<p>通信类的结构</p>
<p><img src="/posts/3e7adddd/image-20211117153318353.png" alt="img"></p>
<p><strong>协议与编码</strong></p>
<p>为了高效的传输信息和读取收到的消息，就需要对消息进行编解码。RemotingCommand这个类在消息传输过程中对所有数据内容进行了封装，不但包含了所有的数据结构还有编解码操作。</p>
<p>消息头：</p>
<table>
<thead>
<tr>
<th><strong>Header字段</strong></th>
<th><strong>类型</strong></th>
<th><strong>Request说明</strong></th>
<th><strong>Response说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的业务处理</td>
<td>应答响应码。0表示成功，非0则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p>消息体</p>
<p><img src="/posts/3e7adddd/image-20211117154638428.png" alt="img"></p>
<p>消息总长度：自个字节，占用一个int类型</p>
<p>序列化类型和消息头长度：同样占用一个int类型，第一个字节表示序列化类型，后面三个字节表示消息头长度。</p>
<p>消息头数据：经过序列化后的消息头数据；</p>
<p>消息主体数据：消息主体的二进制字节数据内容。</p>
<p><strong>通信方式</strong>：同步，异步，单向三种，其中单向一般用在发送心跳包不关注response。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>RocketMQ的负载均衡都在Client端完成。分为Producer发送消息的负载均衡和Consumer端订阅消息的负载均衡。</p>
<h3 id="Producer的负载均衡"><a href="#Producer的负载均衡" class="headerlink" title="Producer的负载均衡"></a>Producer的负载均衡</h3><p>生产者发送消息的时候，会根据topic找到指定的TopicPublishInfo，在获取TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue方法会从TopicPublishInfo中选一个队列发消息。具体的容错策略都是在MQFaultStrategy这个类中定义。MQFaultStrategy中有一个sendLatencyFaultEnable 的私有属性，默认是false，当这个开关打开后会在随机递增基础上过滤掉不可靠的broker代理。是对之前失败的，按一定时间做回退。latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p>
<h3 id="Consumer的负载均衡"><a href="#Consumer的负载均衡" class="headerlink" title="Consumer的负载均衡"></a>Consumer的负载均衡</h3><p>在RocketMQ中，Consumer端的两种消费模式其实都是基于pull拉模式获取消息的，Push模式只是对pull模式的一种封装，其本质上是为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又马不停蹄的继续向服务器再次尝试拉取消息。如果未拉取消息，则延迟一下又会继续拉取。在两种基于拉取模式的消费模式中，都需要Consumer端在知道从Broker端的哪一个消息队列中获取消息，即是Broker端中多个MessageQueue分配到同一个消费组中对应给哪些Consumer消费。</p>
<p>1、consumer端的心跳包发送</p>
<p>在consumer启动之后，他就会通过定时任务不断的向RocketMQ集群中的所有broker实例发送心跳包。broker收到心跳消息之后会在本地维护一个consumerTable，同时将封装好的客户端网络通道信息保存到本地channelInfoTable中为以后做consumer端的负载均衡提供可以依据的数据信息。</p>
<p>2、consumer端实现负载均衡的核心类是RebalanceImpl。</p>
<p>consumer实例启动流程中会启动MQClientInstance实例，会完成负载均衡服务线程RebalanceService的启动，RebalanceService线程的run方法最终会调用RebalanceImpl的rebalanceByTopic方法，这个方法是负载均衡的核心实现。会根据消费者通信类型（广播和集群模式）的不同做不同的处理。</p>
<p>集群模式下的主要处理流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rebalanceByTopic</span><span class="params">(String topic, <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">    Set mqSet;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="built_in">this</span>.messageModel) &#123;</span><br><span class="line">            <span class="comment">//广播模式</span></span><br><span class="line">    <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">        mqSet = (Set)<span class="built_in">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (mqSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="built_in">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                <span class="built_in">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">                log.info(<span class="string">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.consumerGroup, topic, mqSet, mqSet&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, <span class="built_in">this</span>.consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CLUSTERING:<span class="comment">//集群模式</span></span><br><span class="line">            <span class="comment">//从本地缓存变量topicSubscribeInfoTable获取该topic主题下的消费队列集合</span></span><br><span class="line">        mqSet = (Set)<span class="built_in">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">            <span class="comment">//根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取该消费组下消费者Id列表的RPC通信请求</span></span><br><span class="line">        List&lt;String&gt; cidAll = <span class="built_in">this</span>.mQClientFactory.findConsumerIdList(topic, <span class="built_in">this</span>.consumerGroup);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == mqSet &amp;&amp; !topic.startsWith(<span class="string">&quot;%RETRY%&quot;</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, <span class="built_in">this</span>.consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == cidAll) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed&quot;</span>, <span class="built_in">this</span>.consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mqSet != <span class="literal">null</span> &amp;&amp; cidAll != <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            mqAll.addAll(mqSet);</span><br><span class="line">            <span class="comment">//先对消息消费队列，消费者ID进行排序</span></span><br><span class="line">            Collections.sort(mqAll);</span><br><span class="line">            Collections.sort(cidAll);</span><br><span class="line">            <span class="type">AllocateMessageQueueStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="built_in">this</span>.allocateMessageQueueStrategy;</span><br><span class="line">            <span class="type">List</span> <span class="variable">allocateResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//计算待拉取的消息队列</span></span><br><span class="line">                allocateResult = strategy.allocate(<span class="built_in">this</span>.consumerGroup, <span class="built_in">this</span>.mQClientFactory.getClientId(), mqAll, cidAll);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(), var10);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            <span class="keyword">if</span> (allocateResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                allocateResultSet.addAll(allocateResult);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="built_in">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;strategy.getName(), <span class="built_in">this</span>.consumerGroup, topic, <span class="built_in">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(), allocateResultSet.size(), allocateResultSet&#125;);</span><br><span class="line">                <span class="built_in">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/3e7adddd/image-20211117171323228.png" alt="img"></p>
<ul>
<li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</li>
<li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</li>
</ul>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>rocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p>
<p><img src="/posts/3e7adddd/image-20211117171437947.png" alt="img"></p>
<h3 id="事务消息的发送与提交流程。"><a href="#事务消息的发送与提交流程。" class="headerlink" title="事务消息的发送与提交流程。"></a>事务消息的发送与提交流程。</h3><ol>
<li>发送half消息。</li>
<li>服务端响应消息写入结果。</li>
<li>根据发送结果执行本地事务，如果写入失败，该half消息对业务不可见</li>
<li>根据本地事务状态执行commit或者rollback。commit会生成消息索引对业务可见。</li>
</ol>
<p>补偿机制主要是解决当commit或者rollback执行失败之后的挽救措施。</p>
<ol>
<li>对没有commit或者rollback的消息，服务端会进行回查。</li>
<li>生产者检查本地事务消息的状态。</li>
<li>根据状态重新commit或者rollback。</li>
</ol>
<p>RocketMQ事务消息不可见的实现策略：写入的事务消息，会对topic和queue等属性进行替换，正因为消息主题被替换了，所以消息不会转发到原先主题的消费队列中，所以消费者无法感知这个消息的存在。</p>
<h3 id="Op消息的引入"><a href="#Op消息的引入" class="headerlink" title="Op消息的引入"></a>Op消息的引入</h3><p>如果第二阶段是进行Rollback操作，就需要撤销第一阶段的消息，但是不是真正意义上的撤销，因为是顺序写入文件的，但是区别是这条消息没有确定状态，需要一个操作表示这个状态，因此引入了Op消息的概念。Op消息是用来表示事务消息已经确定的状态（要么是Commit要么是Rollback）。如果一条消息没有对应的Op消息，就代表该事务消息还无法确定。</p>
<h3 id="Op消息的存储和对应关系"><a href="#Op消息的存储和对应关系" class="headerlink" title="Op消息的存储和对应关系"></a>Op消息的存储和对应关系</h3><p>rocketMQ将Op消息写入到一个内部的Topic中，这个topic不会被用户消费。Op消息的内容是对应的Half消息的存储的Offset，这样通过Op消息能定位到Half消息，进行后续的操作。</p>
<p><img src="/posts/3e7adddd/image-20211117173342358.png" alt="img"></p>
<h3 id="Half消息的索引构建"><a href="#Half消息的索引构建" class="headerlink" title="Half消息的索引构建"></a>Half消息的索引构建</h3><p>事务消息的第二次提交其实是利用第一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入的流程。</p>
<h3 id="2PC失败时消息该如何处理"><a href="#2PC失败时消息该如何处理" class="headerlink" title="2PC失败时消息该如何处理"></a>2PC失败时消息该如何处理</h3><p>例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。RocketMQ采用了一种补偿机制，称为“<strong>回查</strong>”。Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推CheckPoint（记录那些事务消息的状态是确定的）。</p>
<p>值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查<strong>15</strong>次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</p>
<h2 id="消息的查询"><a href="#消息的查询" class="headerlink" title="消息的查询"></a>消息的查询</h2><p>RocketMQ支持两种查询方式，一种是按照messageID查询，另一种是按照message Key查询。</p>
<ol>
<li>MessageID的长度一共有16个字节，其中包含了消息存储的主机地址，消息CommitLog offset。按照MessageId查询消息“在RocketMQ中具体的做法是：Client端从MessageId解析出Broker的底子好和CommitLog的偏移量之后封装成一个RPC请求通过通信层发送。”</li>
<li>按照Message Key查询消息。这种是基于IndexFile索引文件来实现的。索引文件的结构类似于HashMap。40 Byte 的Header用于保存一些总的统计信息，4<em>500W的 Slot Table并不保存真正的索引数据，而是保存每个槽位对应的单向链表的头。20</em>2000W 是真正的索引数据，即一个 Index File 可以保存 2000W个索引。“按照Message Key查询消息”的方式，RocketMQ的具体做法是，主要通过Broker端的QueryMessageProcessor业务处理器来查询，读取消息的过程就是用topic和key找到IndexFile索引文件中的一条记录，根据其中的commitLog offset从CommitLog文件中读取消息的实体内容。</li>
</ol>
<p><img src="/posts/3e7adddd/image-20211113205859373.png" alt="img"></p>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="MQ的作用？"><a href="#MQ的作用？" class="headerlink" title="MQ的作用？"></a>MQ的作用？</h2><p>降低系统耦合，异步处理提升响应时间，请求到达峰值后，可以保持固定消费速率用于流量削峰。</p>
<h2 id="RocketMQ的角色组成以及各个角色的作用？"><a href="#RocketMQ的角色组成以及各个角色的作用？" class="headerlink" title="RocketMQ的角色组成以及各个角色的作用？"></a>RocketMQ的角色组成以及各个角色的作用？</h2><ol>
<li>Nameserver：无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。</li>
<li>Producer：消息生产者，负责发消息到Broker。</li>
<li>Broker：就是MQ本身，负责转发消息、持久化消息等。</li>
<li>Consumer：消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。</li>
</ol>
<h2 id="消息被消费后会立即删除吗"><a href="#消息被消费后会立即删除吗" class="headerlink" title="消息被消费后会立即删除吗"></a>消息被消费后会立即删除吗</h2><p>不会，每条消息都会持久化到CommitLog中，每个Consumer连接到Broker后会维持消费进度消息，当有消息消费后CommitLog的offerset就更新了。</p>
<h2 id="消息堆积后什么时候会清理过期消息，如何处理"><a href="#消息堆积后什么时候会清理过期消息，如何处理" class="headerlink" title="消息堆积后什么时候会清理过期消息，如何处理"></a>消息堆积后什么时候会清理过期消息，如何处理</h2><p>4.6版本默认48小时候会删除不再使用的commitLog文件。检查这个文件最后的访问时间，并判断是否大于过期时间，指定时间删除，默认凌晨4点。</p>
<h2 id="消息堆积会不会进入到死信队列"><a href="#消息堆积会不会进入到死信队列" class="headerlink" title="消息堆积会不会进入到死信队列"></a>消息堆积会不会进入到死信队列</h2><p>不会，消息在消费失败之后会进入重试队列，默认重试16次才会进入死信队列。</p>
<h2 id="死信队列的作用以及队列里消息的保存时间"><a href="#死信队列的作用以及队列里消息的保存时间" class="headerlink" title="死信队列的作用以及队列里消息的保存时间"></a>死信队列的作用以及队列里消息的保存时间</h2><p>死信队列用于存储消费失败的消息，消息消费失败重试次数达到阈值默认是16次会放入死信队列，死信队列中的消息默认保存时间是72小时，你可以在消息队列控制台查询消息以及重发死信队列中的消息。</p>
<ol>
<li>代码正常执行返回消息状态为CONSUME_SUCCESS，执行异常返回RECONSUME_LATER</li>
<li>状态为RECONSUME_LATER的消息会进入到重试队列，重试队列的名称为 %RETRY% + ConsumerGroupName；</li>
<li>重试16次消息任然没有处理成功，消息就会进入到死信队列%DLQ% + ConsumerGroupName;</li>
</ol>
<h2 id="消息消费的模式"><a href="#消息消费的模式" class="headerlink" title="消息消费的模式"></a>消息消费的模式</h2><ul>
<li>集群消费：一条消息只会被一个Group中的一个Consumer消费</li>
<li>广播消费：多个Group同时消费一个Topic时，每个Group中的Consumer都会消费这条数据。</li>
</ul>
<h2 id="Broker如何处理pull请求的"><a href="#Broker如何处理pull请求的" class="headerlink" title="Broker如何处理pull请求的"></a>Broker如何处理pull请求的</h2><p>Consumer首次请求Broker</p>
<ul>
<li><p>Broker中是否有符合条件的消息</p>
</li>
<li><p>有 -&gt;</p>
</li>
<li><ul>
<li>响应Consumer</li>
<li>等待下次Consumer的请求</li>
</ul>
</li>
<li><p>没有</p>
</li>
<li><ul>
<li>DefaultMessageStore#ReputMessageService#run方法</li>
<li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li>
<li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li>
<li>当有新消息的时候返回请求</li>
<li>挂起consumer的请求，即不断开连接，也不返回数据</li>
</ul>
</li>
</ul>
<h2 id="如何做负载均衡"><a href="#如何做负载均衡" class="headerlink" title="如何做负载均衡"></a>如何做负载均衡</h2><p>RocketMQ中的负载均衡都在Client端完成，具体来说，主要可以分为Producer端发送消息时的负载均衡和Consumer端订阅消息的负载均衡。消费消息的方式push&amp;pull实际上均由pull模式实现，所以具体负载均衡是在客户端完成的。核心类—RebalanceImpl 在Consumer启动的过程中会完成RebalanceService启动，每20s执行一次，最终调用RebalanceImpl来实现。</p>
<h2 id="如何避免重复消费"><a href="#如何避免重复消费" class="headerlink" title="如何避免重复消费"></a>如何避免重复消费</h2><ul>
<li>数据库表中定义为以约束，如果有重复数据插入报唯一键冲突</li>
<li>Redis设置全局唯一业务ID，处理前查一下，如果有的话就不处理，否则在处理后面逻辑。</li>
<li>分布式锁</li>
</ul>
<h2 id="如何保证有序消费"><a href="#如何保证有序消费" class="headerlink" title="如何保证有序消费"></a>如何保证有序消费</h2><p>首先多个队列只能保证单个队列中的消息有序，同一个topic同一个队列发消息的时候一个线程发送，消费的时候单线程消费。</p>
<p>发送消息通过id对队列个数取余保证同一个消息发送到同一个queue。</p>
<h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><ul>
<li>Producer：采取send()同步发送消息，发送结果是同步感知的，发送失败可以重试，默认重试3次。</li>
<li>broker：修改刷盘策略为同步刷盘，默认是异步刷盘。集群部署，主从模式，高可用</li>
<li>consumer：完全消费后手动ACK确认。</li>
</ul>
<h2 id="RocketMQ分布式事务的原理"><a href="#RocketMQ分布式事务的原理" class="headerlink" title="RocketMQ分布式事务的原理"></a>RocketMQ分布式事务的原理</h2><p>事务消息处理流程</p>
<p><img src="/posts/3e7adddd/image.png" alt="img"></p>
<p>事务消息的生命周期</p>
<p><img src="/posts/3e7adddd/image.png" alt="img"></p>
<p>事务消息的使用限制</p>
<ul>
<li>事务消息仅支持在<strong>MessageType</strong>为<strong>Transaction</strong>的主题内使用，即事务消息只能发送至类型为事务消息的主题中，发送的消息的类型必须和主题的类型一致。</li>
<li>RocketMQ事务消息保证最终一致性，但是上下游系统事务之间的中间状态不一定一致。</li>
<li>如果Half Message发送到Broker之后，如果在指定时间内服务端无法确认提交或者回滚状态，则消息默认会被回滚。</li>
</ul>
<h2 id="如何优化性能（Producer和Consumer）"><a href="#如何优化性能（Producer和Consumer）" class="headerlink" title="如何优化性能（Producer和Consumer）"></a>如何优化性能（Producer和Consumer）</h2><ul>
<li>同一个消费者组，多台机器部署，并行消费</li>
<li>单个Consumer提高消费线程个数</li>
<li>批量消费（消息批量拉取，业务逻辑批量处理）</li>
<li>Page Cache，JVM调优，多线程</li>
</ul>
<h2 id="NameServer的作用"><a href="#NameServer的作用" class="headerlink" title="NameServer的作用"></a>NameServer的作用</h2><p>Broker的信息（IP，topic对应）会注册到所有的NameServer。</p>
<h2 id="Broker宕机了怎么办"><a href="#Broker宕机了怎么办" class="headerlink" title="Broker宕机了怎么办"></a>Broker宕机了怎么办</h2><p>Broker主从架构以及多副本策略，Master收到消息后同步给Slave，这样消息不止一份，可以保证MQ的可靠性和高可用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/ynyhl/p/11320797.html">kafka和RocketMQ对比</a></p>
<p><a href="https://github.com/apache/rocketmq">github:RocketMQ</a></p>
<p><a href="https://www.cnblogs.com/javazhiyin/p/13327925.html">https://www.cnblogs.com/javazhiyin/p/13327925.html</a></p>
<p><a href="https://help.aliyun.com/document_detail/440244.html">https://help.aliyun.com/document_detail/440244.html</a></p>
]]></content>
      <tags>
        <tag>rocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/posts/3ad834c9/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
</search>
